#  浅谈在数据包被加密和签名保护时的高阶渗透方式

[ 夜组安全 ](javascript:void\(0\);)

**夜组安全** ![]()

微信号 NightCrawler_Team

功能介绍 "恐惧就是貌似真实的伪证" NightCrawler Team(简称:夜组)主攻WEB安全 | 内网渗透 | 红蓝对抗 | 代码审计 |
APT攻击，致力于将每一位藏在暗处的白帽子聚集在一起，在夜空中划出一道绚丽的光线！

____

___发表于_

收录于合集 #高阶渗透 1个

免责声明

由于传播、利用本公众号夜组安全所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，公众号夜组安全及作者不为此承担任何责任，一旦造成后果请自行承担！如有侵权烦请告知，我们会立即删除并致歉。谢谢！

朋友们现在只对常读和星标的公众号才展示大图推送，建议大家把 **夜组安全** “ **设为星标** ”，否则可能就看不到了啦！

![]()![]()

 **高阶渗透**

![]()![]()

 **01**

 **场景**

在金融银行类安全测试中，经常见到数据包加密、签名保护，这种业务不能直接进行有效的安全测试，修改数据包参数会重放失败，爬虫见到密文也是懵逼。

![]()

![]()

 **02**

 **测试套路**

对于这种业务，不管是手工还是借助工具，需要先还原加密算法（或者签名保护算法）。知道了加密逻辑后，就可以开发burp插件完成明文状态下的安全测试，最后借助密文数据天然过waf的优势结合Xray等漏扫工具完成半自动的安全测试（逻辑漏洞还得需要手工测）。笔者通过几个案例介绍这类业务的通用测试流程：常见加密算法分析流程、burp插件开发、联动Xray半自动化挖洞。  

  

所以案例只是案例，读者不要纠结于这些案例中的加密算法，因为加密有很多组合形式。主要是通过本文介绍这类业务的通用测试方法，降低安全测试的人力成本。

  

 **03**

 **案例**

常见签名的生成算法：sign = MD5( sort( 业务参数+时间戳+其他参数)
)，拼接业务参数+时间戳+其他参数，对字符串排序，计算字符串MD5作为sign。客户端和服务端使用相同的算法生成sign，服务端接收到请求后，先计算一次sign，如果业务参数、时间戳、其他参数中有一个被修改过，得到的sign就与客户端发送过来sign不一致，签名校验就会失败，不再处理请求。

### 签名校验

1、不修改数据包，重放请求，此时可以正常响应

![]()

2、然后修改参数icon_type的值为11，再次重放，此时会提示"message":"sign
invalid"，请求中的api_sign是签名的值，需要知道api_sign是怎么计算出来的

![]()

3、用url参数作为关键字搜索，在js中定位api_sign，设置断点

![]()

4、刷新网页，停在了断点位置，单步步入进入函数内部,可以看到加入了两个参数app_key、app_pwd，然后单步往下走，参数c的值此时为device_id=069c8db0-af49-11ed-9a08-3b99f11ff116×tamp=1676725825997&session_token=G2de7f3ab78910b46ad8c07d6e25c627&app_key=f6aefd6691f04573bdf9e044137372bc，也就是所有url参数

![]()

5、继续单步走，进行了一次排序，c的值为app_key=f6aefd6691f04573bdf9e044137372bc&device_id=069c8db0-af49-11ed-9a08-3b99f11ff116&session_token=G2de7f3ab78910b46ad8c07d6e25c627×tamp=1676725825997

![]()

6、之后就是拼接字符串，app_key+"Oic"+app_pwd+"QeeeS99u3d"+c+app_key+app_pwd

![]()

7、得到的字符串为：  
f6aefd6691f04573bdf9e044137372bcOic72e78efefe6b4577a1f7afbca56b6e28993c06ea4bb84cde8dd70e582dbc76cbQeeeS99u3dapp_key=f6aefd6691f04573bdf9e044137372bc&device_id=069c8db0-af49-11ed-9a08-3b99f11ff116&session_token=G2de7f3ab78910b46ad8c07d6e25c627×tamp=1676725825997f6aefd6691f04573bdf9e044137372bc72e78efefe6b4577a1f7afbca56b6e28993c06ea4bb84cde8dd70e582dbc76cb

8、最后获取这个字符串的MD5，就是签名api_sign的值

![]()

9、还原了api_sign的计算方式，就可以开发burp插件自动更新签名校验的参数api_sign

  

### 用burp插件自动更新签名

burp插件的接口开发知识不再单独介绍了，否则篇幅会太冗长，在文中数据包加解密和签名保护绕过这块，没有涉及到太多复杂的开发知识。插件的学习可以参考官方文档和官方的代码demo，代码量不算多https://portswigger.net/burp/extender/api/index.html

首先在processHttpMessage中，检查uri参数，移除原来参数api_sign

![]()

根据修改后的uri参数，使用已还原的api_sign生成算法得到新的api_sign

![]()

此时修改参数，重放请求后，插件会自动更新url中api_sign的值（ps：下面这两个截图是笔者随意找的测试站点，url参数也是自己加的，读者根据上下文理解意思即可）

![]()

在控制台查看更新的api_sign，此时修改请求参数做安全测试就不再受签名保护限制了

![]()

#### 数据包分段加密

一个H5应用，在微信可以正常访问，放到浏览器访问限制

![]()

修改一下User-Agent，修改为安卓或ios手机的UserAgent，再刷新页面后能正常访问

![]()

随便输入一个卡号后先抓个包看看

![]()

数据包都做了加密

![]()

任意修改一个密文字符，把第一个字符c改成1，服务端不能正常处理密文

![]()

直接发明文包不行，明文会被当成密文去解密

![]()

使用数据包的参数encryptData定位加密代码位置，展开js文件，搜索关键字；单击{}格式化js，方便阅读

![]()

单步步入调试进入pten函数，参数e是默认DES密钥

![]()

查看setMd5的入参，可以debug一行一行看

![]()

也可以将方法代码放到控制台查看

![]()

可以看到第一部分MD5的构造是原始参数json+DES密钥e，拼接后做MD5

![]()

setDES这部分是ECB模式，Pkcs7填充的DES加密，密钥是e

![]()

参数n是rsa加密DES密钥得到的密文，是一个固定值。最后返回MD5+splitStr+DES加密后参数+splitStr+rsa加密的DES密钥

![]()

splitStr是一个分割字符，用于将不同加密加密方式得到的密文分割开，服务端收到密文后，按splitStr分割密文，再逐段解密

![]()

拿到控制台看看是什么字符

![]()

也就是数据包中见到的\u001d

![]()

![]()

验证一下：解密中间部分的密文, 得到原始参数的json

![]()

ptde函数用于解密返回包的密文

![]()

单步步入getDESModeEBC函数，使用密钥e进行DES解密，没有其他处理

![]()

在线解密验证下

![]()

得到结论：  
请求包的加密：MD5(原始参数+DES密钥)+”\u001d”+DES(原始参数) +”\u001d”+RSA(DES密钥)  
返回包的解密：直接用DES密钥解密即可

  

### 分段解密

用正则获取两个\u001d中间的密文，

![]()

解密后在burp控制台打印，看看能不能正常解密

![]()

明文请求的body则加密后重新封包

![]()

这时候使用明文发包没问题了

![]()

使用IMessageEditorTab在burp中增加一个控件，用于获取解密后的完整请求包，在IMessageEditorTab中填入header和解密后的原始参数

![]()

先判断是否请求中包含参数encryptData

![]()

包含则说明是密文包，再启用控件，解密密文

![]()

点击“参数明文”控件，获取到了解密后的完整请求包，对明文参数进行安全测试，重放后插件会自动完成密文构造

![]()

对于变化的密钥，可以提供一个ui界面，在输入框设置密钥，rsa等动态变化的值

![]()

最后需要把返回包的密文也处理掉，由于在burp插件开发中返回包没有参数的概念，只能通过偏移获取body，解密后，用明文替换密文，再用IMessageEditorTab展示解密后的数据包

![]()

此时原始响应还是密文，因为客户端需要解密这个密文，IMessageEditorTab中明文只是展示作用，辅助安全测试，不会返回给客户端  

![]()

encryptData中的密文被替换为明文展示，之后的安全测试就完全是明文了  

![]()

### 自动BypassWAF 联动Xray

这也是数据包加密给安全测试人员的彩蛋吧，数据包加密有一个好处：天然对waf等态势感知设备免疫，自带绕过属性：  
明文的payload会被waf识别  

![]()

如果直接扫描原始请求，会触发WAF拦截

![]()

加密后waf没法再识别，如果还原了加密算法，也就间接的绕过了waf（但是，除了前置的waf，应用程序自身也会对参数做合法性校验）

![]()

控制台打印加密的payload

![]()

于是可以结合漏扫工具做半自动的安全测试（逻辑漏洞还是需要手工测试），示意图如下

![]()

1、burpA中联动Xray  

![]()

2、开启联动Xray的开关

![]()

3、这个开关用于控制是否对明文请求包做加密，在联动Xray时，需要给Xray明文包，所以开启后从burpA重放的明文请求包不做加密，直接给Xray去做payload构造

![]()

4、设置Xray的代理

![]()

5、burpB作为Xray的代理

![]()

6、将插件代码拷贝一份，打包为另一个插件，作为联动Xray的专用插件。其他代码不用动，只修改BurpExtender.java中processHttpMessage方法代码：只处理经过Proxy的http流量，做两件事：加密请求body，解密响应body

![]()

7、启动Xray监听127.0.0.1:7777, 在burpA的Repeater中重放明文请求包

![]()

8、Xrays收到burpA的明文请求，在明文包构造payload，开始扫描，从Xray日志可以看到，未触发WAF

![]()

9、burpB收到Xray的明文请求，加密请求中明文中包含payload的body再发给服务端，扫描器能正常工

![]()

10、查看控制台打印的密文body：

![]()

11、burpB解密响应的密文body后返回给Xray，从状态码和返回包可以看到未触发WAF拦截，Xray再根据明文响应包内容判断是否存在漏洞

![]()

  

高阶渗透yyds  

 **04**

 **参考链接**

文章来源：先知社区-1615078760777882

原文链接：https://xz.aliyun.com/t/12295

 **05**

 **往期精彩**

[ ![]()

tql高质量常用字典，提高渗透效率!

](http://mp.weixin.qq.com/s?__biz=Mzk0ODM0NDIxNQ==&mid=2247486065&idx=1&sn=2aeaec1fe452bc3897957be3ed414cb6&chksm=c3684e89f41fc79f1d7e7bc6f0ab0e17a634203c5ca68dff07357010c3548641b1b9ba717a68&scene=21#wechat_redirect)

  

[ ![]()

【实战】记一次挖矿应急响应

](http://mp.weixin.qq.com/s?__biz=Mzk0ODM0NDIxNQ==&mid=2247486053&idx=1&sn=7f6c6e7b9da43e184ac03c4d92a8b6ec&chksm=c3684e9df41fc78baa2c07ae99e820dff64dc6fdb254b79376410d96696eae9f37a079e46ea5&scene=21#wechat_redirect)

  

![]()

预览时标签不可点

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。   视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

